var _t=Object.defineProperty;var D=(p,k)=>_t(p,"name",{value:k,configurable:!0});import{R as ue,r as $e,a as le,j as z}from"./jsx-runtime.0c332e8b.js";var st={exports:{}};(function(p,k){(function(A,O){p.exports=O()})(self,()=>{return A={7629:(S,w,b)=>{const o=b(375),v=b(8571),g=b(9474),f=b(1687),e=b(8652),n=b(8160),a=b(3292),s=b(6354),t=b(8901),l=b(9708),r=b(6914),i=b(2294),c=b(6133),d=b(1152),y=b(8863),x=b(2036),_={Base:class{constructor(u){this.type=u,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new i.Ids,this._preferences=null,this._refs=new c.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return o(typeof l.describe=="function","Manifest functionality disabled"),l.describe(this)}allow(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];return n.verifyFlat(m,"allow"),this._values(m,"_valids")}alter(u){o(u&&typeof u=="object"&&!Array.isArray(u),"Invalid targets argument"),o(!this._inRuleset(),"Cannot set alterations inside a ruleset");const m=this.clone();m.$_terms.alterations=m.$_terms.alterations||[];for(const h in u){const $=u[h];o(typeof $=="function","Alteration adjuster for",h,"must be a function"),m.$_terms.alterations.push({target:h,adjuster:$})}return m.$_temp.ruleset=!1,m}artifact(u){return o(u!==void 0,"Artifact cannot be undefined"),o(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",u)}cast(u){return o(u===!1||typeof u=="string","Invalid to value"),o(u===!1||this._definition.cast[u],"Type",this.type,"does not support casting to",u),this.$_setFlag("cast",u===!1?void 0:u)}default(u,m){return this._default("default",u,m)}description(u){return o(u&&typeof u=="string","Description must be a non-empty string"),this.$_setFlag("description",u)}empty(u){const m=this.clone();return u!==void 0&&(u=m.$_compile(u,{override:!1})),m.$_setFlag("empty",u,{clone:!1})}error(u){return o(u,"Missing error"),o(u instanceof Error||typeof u=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",u)}example(u){let m=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return o(u!==void 0,"Missing example"),n.assertOptions(m,["override"]),this._inner("examples",u,{single:!0,override:m.override})}external(u,m){return typeof u=="object"&&(o(!m,"Cannot combine options with description"),m=u.description,u=u.method),o(typeof u=="function","Method must be a function"),o(m===void 0||m&&typeof m=="string","Description must be a non-empty string"),this._inner("externals",{method:u,description:m},{single:!0})}failover(u,m){return this._default("failover",u,m)}forbidden(){return this.presence("forbidden")}id(u){return u?(o(typeof u=="string","id must be a non-empty string"),o(/^[^\.]+$/.test(u),"id cannot contain period character"),this.$_setFlag("id",u)):this.$_setFlag("id",void 0)}invalid(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];return this._values(m,"_invalids")}label(u){return o(u&&typeof u=="string","Label name must be a non-empty string"),this.$_setFlag("label",u)}meta(u){return o(u!==void 0,"Meta cannot be undefined"),this._inner("metas",u,{single:!0})}note(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];o(m.length,"Missing notes");for(const $ of m)o($&&typeof $=="string","Notes must be non-empty strings");return this._inner("notes",m)}only(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return o(typeof u=="boolean","Invalid mode:",u),this.$_setFlag("only",u)}optional(){return this.presence("optional")}prefs(u){o(u,"Missing preferences"),o(u.context===void 0,"Cannot override context"),o(u.externals===void 0,"Cannot override externals"),o(u.warnings===void 0,"Cannot override warnings"),o(u.debug===void 0,"Cannot override debug"),n.checkPreferences(u);const m=this.clone();return m._preferences=n.preferences(m._preferences,u),m}presence(u){return o(["optional","required","forbidden"].includes(u),"Unknown presence mode",u),this.$_setFlag("presence",u)}raw(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("result",u?"raw":void 0)}result(u){return o(["raw","strip"].includes(u),"Unknown result mode",u),this.$_setFlag("result",u)}required(){return this.presence("required")}strict(u){const m=this.clone(),h=u!==void 0&&!u;return m._preferences=n.preferences(m._preferences,{convert:h}),m}strip(){let u=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("result",u?"strip":void 0)}tag(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];o(m.length,"Missing tags");for(const $ of m)o($&&typeof $=="string","Tags must be non-empty strings");return this._inner("tags",m)}unit(u){return o(u&&typeof u=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",u)}valid(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];n.verifyFlat(m,"valid");const $=this.allow(...m);return $.$_setFlag("only",!!$._valids,{clone:!1}),$}when(u,m){const h=this.clone();h.$_terms.whens||(h.$_terms.whens=[]);const $=a.when(h,u,m);if(!["any","link"].includes(h.type)){const j=$.is?[$]:$.switch;for(const E of j)o(!E.then||E.then.type==="any"||E.then.type===h.type,"Cannot combine",h.type,"with",E.then&&E.then.type),o(!E.otherwise||E.otherwise.type==="any"||E.otherwise.type===h.type,"Cannot combine",h.type,"with",E.otherwise&&E.otherwise.type)}return h.$_terms.whens.push($),h.$_mutateRebuild()}cache(u){o(!this._inRuleset(),"Cannot set caching inside a ruleset"),o(!this._cache,"Cannot override schema cache"),o(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const m=this.clone();return m._cache=u||e.provider.provision(),m.$_temp.ruleset=!1,m}clone(){const u=Object.create(Object.getPrototypeOf(this));return this._assign(u)}concat(u){o(n.isSchema(u),"Invalid schema object"),o(this.type==="any"||u.type==="any"||u.type===this.type,"Cannot merge type",this.type,"with another type:",u.type),o(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),o(!u._inRuleset(),"Cannot concatenate a schema with open ruleset");let m=this.clone();if(this.type==="any"&&u.type!=="any"){const h=u.clone();for(const $ of Object.keys(m))$!=="type"&&(h[$]=m[$]);m=h}m._ids.concat(u._ids),m._refs.register(u,c.toSibling),m._preferences=m._preferences?n.preferences(m._preferences,u._preferences):u._preferences,m._valids=x.merge(m._valids,u._valids,u._invalids),m._invalids=x.merge(m._invalids,u._invalids,u._valids);for(const h of u._singleRules.keys())m._singleRules.has(h)&&(m._rules=m._rules.filter($=>$.keep||$.name!==h),m._singleRules.delete(h));for(const h of u._rules)u._definition.rules[h.method].multi||m._singleRules.set(h.name,h),m._rules.push(h);if(m._flags.empty&&u._flags.empty){m._flags.empty=m._flags.empty.concat(u._flags.empty);const h=Object.assign({},u._flags);delete h.empty,f(m._flags,h)}else if(u._flags.empty){m._flags.empty=u._flags.empty;const h=Object.assign({},u._flags);delete h.empty,f(m._flags,h)}else f(m._flags,u._flags);for(const h in u.$_terms){const $=u.$_terms[h];$?m.$_terms[h]?m.$_terms[h]=m.$_terms[h].concat($):m.$_terms[h]=$.slice():m.$_terms[h]||(m.$_terms[h]=$)}return this.$_root._tracer&&this.$_root._tracer._combine(m,[this,u]),m.$_mutateRebuild()}extend(u){return o(!u.base,"Cannot extend type with another base"),t.type(this,u)}extract(u){return u=Array.isArray(u)?u:u.split("."),this._ids.reach(u)}fork(u,m){o(!this._inRuleset(),"Cannot fork inside a ruleset");let h=this;for(let $ of[].concat(u))$=Array.isArray($)?$:$.split("."),h=h._ids.fork($,m,h);return h.$_temp.ruleset=!1,h}rule(u){const m=this._definition;n.assertOptions(u,Object.keys(m.modifiers)),o(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const h=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;o(h>=0&&h<this._rules.length,"Cannot apply rules to empty ruleset");const $=this.clone();for(let j=h;j<$._rules.length;++j){const E=$._rules[j],N=v(E);for(const M in u)m.modifiers[M](N,u[M]),o(N.name===E.name,"Cannot change rule name");$._rules[j]=N,$._singleRules.get(N.name)===E&&$._singleRules.set(N.name,N)}return $.$_temp.ruleset=!1,$.$_mutateRebuild()}get ruleset(){o(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const u=this.clone();return u.$_temp.ruleset=u._rules.length,u}get $(){return this.ruleset}tailor(u){u=[].concat(u),o(!this._inRuleset(),"Cannot tailor inside a ruleset");let m=this;if(this.$_terms.alterations)for(const{target:h,adjuster:$}of this.$_terms.alterations)u.includes(h)&&(m=$(m),o(n.isSchema(m),"Alteration adjuster for",h,"failed to return a schema object"));return m=m.$_modify({each:h=>h.tailor(u),ref:!1}),m.$_temp.ruleset=!1,m.$_mutateRebuild()}tracer(){return d.location?d.location(this):this}validate(u,m){return y.entry(u,this,m)}validateAsync(u,m){return y.entryAsync(u,this,m)}$_addRule(u){typeof u=="string"&&(u={name:u}),o(u&&typeof u=="object","Invalid options"),o(u.name&&typeof u.name=="string","Invalid rule name");for(const E in u)o(E[0]!=="_","Cannot set private rule properties");const m=Object.assign({},u);m._resolve=[],m.method=m.method||m.name;const h=this._definition.rules[m.method],$=m.args;o(h,"Unknown rule",m.method);const j=this.clone();if($){o(Object.keys($).length===1||Object.keys($).length===this._definition.rules[m.name].args.length,"Invalid rule definition for",this.type,m.name);for(const E in $){let N=$[E];if(h.argsByName){const M=h.argsByName.get(E);if(M.ref&&n.isResolvable(N))m._resolve.push(E),j.$_mutateRegister(N);else if(M.normalize&&(N=M.normalize(N),$[E]=N),M.assert){const V=n.validateArg(N,E,M);o(!V,V,"or reference")}}N!==void 0?$[E]=N:delete $[E]}}return h.multi||(j._ruleRemove(m.name,{clone:!1}),j._singleRules.set(m.name,m)),j.$_temp.ruleset===!1&&(j.$_temp.ruleset=null),h.priority?j._rules.unshift(m):j._rules.push(m),j}$_compile(u,m){return a.schema(this.$_root,u,m)}$_createError(u,m,h,$,j){let E=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{};const N=E.flags!==!1?this._flags:{},M=E.messages?r.merge(this._definition.messages,E.messages):this._definition.messages;return new s.Report(u,m,h,N,M,$,j)}$_getFlag(u){return this._flags[u]}$_getRule(u){return this._singleRules.get(u)}$_mapLabels(u){return u=Array.isArray(u)?u:u.split("."),this._ids.labels(u)}$_match(u,m,h,$){(h=Object.assign({},h)).abortEarly=!0,h._externals=!1,m.snapshot();const j=!y.validate(u,this,m,h,$).errors;return m.restore(),j}$_modify(u){return n.assertOptions(u,["each","once","ref","schema"]),i.schema(this,u)||this}$_mutateRebuild(){return o(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(u,m)=>{let{source:h,name:$,path:j,key:E}=m;const N=this._definition[h][$]&&this._definition[h][$].register;N!==!1&&this.$_mutateRegister(u,{family:N,key:E})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(u){let{family:m,key:h}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this._refs.register(u,m),this._ids.register(u,{key:h})}$_property(u){return this._definition.properties[u]}$_reach(u){return this._ids.reach(u)}$_rootReferences(){return this._refs.roots()}$_setFlag(u,m){let h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};o(u[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const $=this._definition.flags[u]||{};if(g(m,$.default)&&(m=void 0),g(m,this._flags[u]))return this;const j=h.clone!==!1?this.clone():this;return m!==void 0?(j._flags[u]=m,j.$_mutateRegister(m)):delete j._flags[u],u[0]!=="_"&&(j.$_temp.ruleset=!1),j}$_parent(u){for(var m=arguments.length,h=new Array(m>1?m-1:0),$=1;$<m;$++)h[$-1]=arguments[$];return this[u][n.symbols.parent].call(this,...h)}$_validate(u,m,h){return y.validate(u,this,m,h)}_assign(u){u.type=this.type,u.$_root=this.$_root,u.$_temp=Object.assign({},this.$_temp),u.$_temp.whens={},u._ids=this._ids.clone(),u._preferences=this._preferences,u._valids=this._valids&&this._valids.clone(),u._invalids=this._invalids&&this._invalids.clone(),u._rules=this._rules.slice(),u._singleRules=v(this._singleRules,{shallow:!0}),u._refs=this._refs.clone(),u._flags=Object.assign({},this._flags),u._cache=null,u.$_terms={};for(const m in this.$_terms)u.$_terms[m]=this.$_terms[m]?this.$_terms[m].slice():null;u.$_super={};for(const m in this.$_super)u.$_super[m]=this._super[m].bind(u);return u}_bare(){const u=this.clone();u._reset();const m=u._definition.terms;for(const h in m){const $=m[h];u.$_terms[h]=$.init}return u.$_mutateRebuild()}_default(u,m){let h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return n.assertOptions(h,"literal"),o(m!==void 0,"Missing",u,"value"),o(typeof m=="function"||!h.literal,"Only function value supports literal option"),typeof m=="function"&&h.literal&&(m={[n.symbols.literal]:!0,literal:m}),this.$_setFlag(u,m)}_generate(u,m,h){if(!this.$_terms.whens)return{schema:this};const $=[],j=[];for(let M=0;M<this.$_terms.whens.length;++M){const V=this.$_terms.whens[M];if(V.concat){$.push(V.concat),j.push(`${M}.concat`);continue}const W=V.ref?V.ref.resolve(u,m,h):u,K=V.is?[V]:V.switch,ne=j.length;for(let oe=0;oe<K.length;++oe){const{is:B,then:H,otherwise:te}=K[oe],ee=`${M}${V.switch?"."+oe:""}`;if(B.$_match(W,m.nest(B,`${ee}.is`),h)){if(H){const pe=m.localize([...m.path,`${ee}.then`],m.ancestors,m.schemas),{schema:be,id:ge}=H._generate(u,pe,h);$.push(be),j.push(`${ee}.then${ge?`(${ge})`:""}`);break}}else if(te){const pe=m.localize([...m.path,`${ee}.otherwise`],m.ancestors,m.schemas),{schema:be,id:ge}=te._generate(u,pe,h);$.push(be),j.push(`${ee}.otherwise${ge?`(${ge})`:""}`);break}}if(V.break&&j.length>ne)break}const E=j.join(", ");if(m.mainstay.tracer.debug(m,"rule","when",E),!E)return{schema:this};if(!m.mainstay.tracer.active&&this.$_temp.whens[E])return{schema:this.$_temp.whens[E],id:E};let N=this;this._definition.generate&&(N=this._definition.generate(this,u,m,h));for(const M of $)N=N.concat(M);return this.$_root._tracer&&this.$_root._tracer._combine(N,[this,...$]),this.$_temp.whens[E]=N,{schema:N,id:E}}_inner(u,m){let h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};o(!this._inRuleset(),`Cannot set ${u} inside a ruleset`);const $=this.clone();return $.$_terms[u]&&!h.override||($.$_terms[u]=[]),h.single?$.$_terms[u].push(m):$.$_terms[u].push(...m),$.$_temp.ruleset=!1,$}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(u){let m=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!this._singleRules.has(u))return this;const h=m.clone!==!1?this.clone():this;h._singleRules.delete(u);const $=[];for(let j=0;j<h._rules.length;++j){const E=h._rules[j];E.name!==u||E.keep?$.push(E):h._inRuleset()&&j<h.$_temp.ruleset&&--h.$_temp.ruleset}return h._rules=$,h}_values(u,m){n.verifyFlat(u,m.slice(1,-1));const h=this.clone(),$=u[0]===n.symbols.override;if($&&(u=u.slice(1)),!h[m]&&u.length?h[m]=new x:$&&(h[m]=u.length?new x:null,h.$_mutateRebuild()),!h[m])return h;$&&h[m].override();for(const j of u){o(j!==void 0,"Cannot call allow/valid/invalid with undefined"),o(j!==n.symbols.override,"Override must be the first value");const E=m==="_invalids"?"_valids":"_invalids";h[E]&&(h[E].remove(j),h[E].length||(o(m==="_valids"||!h._flags.only,"Setting invalid value",j,"leaves schema rejecting all values due to previous valid rule"),h[E]=null)),h[m].add(j,h._refs)}return h}}};_.Base.prototype[n.symbols.any]={version:n.version,compile:a.compile,root:"$_root"},_.Base.prototype.isImmutable=!0,_.Base.prototype.deny=_.Base.prototype.invalid,_.Base.prototype.disallow=_.Base.prototype.invalid,_.Base.prototype.equal=_.Base.prototype.valid,_.Base.prototype.exist=_.Base.prototype.required,_.Base.prototype.not=_.Base.prototype.invalid,_.Base.prototype.options=_.Base.prototype.prefs,_.Base.prototype.preferences=_.Base.prototype.prefs,S.exports=new _.Base},8652:(S,w,b)=>{const o=b(375),v=b(8571),g=b(8160),f={max:1e3,supported:new Set(["undefined","boolean","number","string"])};w.provider={provision:e=>new f.Cache(e)},f.Cache=class{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};g.assertOptions(e,["max"]),o(e.max===void 0||e.max&&e.max>0&&isFinite(e.max),"Invalid max cache size"),this._max=e.max||f.max,this._map=new Map,this._list=new f.List}get length(){return this._map.size}set(e,n){if(e!==null&&!f.supported.has(typeof e))return;let a=this._map.get(e);if(a)return a.value=n,void this._list.first(a);a=this._list.unshift({key:e,value:n}),this._map.set(e,a),this._compact()}get(e){const n=this._map.get(e);if(n)return this._list.first(n),v(n.value)}_compact(){if(this._map.size>this._max){const e=this._list.pop();this._map.delete(e.key)}}},f.List=class{constructor(){this.tail=null,this.head=null}unshift(e){return e.next=null,e.prev=this.head,this.head&&(this.head.next=e),this.head=e,this.tail||(this.tail=e),e}first(e){e!==this.head&&(this._remove(e),this.unshift(e))}pop(){return this._remove(this.tail)}_remove(e){const{next:n,prev:a}=e;return n.prev=a,a&&(a.next=n),e===this.tail&&(this.tail=n),e.prev=null,e.next=null,e}}},8160:(S,w,b)=>{const o=b(375),v=b(7916),g=b(5934);let f,e;const n={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};w.version=g.version,w.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},w.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},w.assertOptions=function(a,s){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"Options";o(a&&typeof a=="object"&&!Array.isArray(a),"Options must be of type object");const l=Object.keys(a).filter(r=>!s.includes(r));o(l.length===0,`${t} contain unknown keys: ${l}`)},w.checkPreferences=function(a){e=e||b(3378);const s=e.preferences.validate(a);if(s.error)throw new v([s.error.details[0].message])},w.compare=function(a,s,t){switch(t){case"=":return a===s;case">":return a>s;case"<":return a<s;case">=":return a>=s;case"<=":return a<=s}},w.default=function(a,s){return a===void 0?s:a},w.isIsoDate=function(a){return n.isoDate.test(a)},w.isNumber=function(a){return typeof a=="number"&&!isNaN(a)},w.isResolvable=function(a){return!!a&&(a[w.symbols.ref]||a[w.symbols.template])},w.isSchema=function(a){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const t=a&&a[w.symbols.any];return!!t&&(o(s.legacy||t.version===w.version,"Cannot mix different versions of joi schemas"),!0)},w.isValues=function(a){return a[w.symbols.values]},w.limit=function(a){return Number.isSafeInteger(a)&&a>=0},w.preferences=function(a,s){f=f||b(6914),a=a||{},s=s||{};const t=Object.assign({},a,s);return s.errors&&a.errors&&(t.errors=Object.assign({},a.errors,s.errors),t.errors.wrap=Object.assign({},a.errors.wrap,s.errors.wrap)),s.messages&&(t.messages=f.compile(s.messages,a.messages)),delete t[w.symbols.prefs],t},w.tryWithPath=function(a,s){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};try{return a()}catch(l){throw l.path!==void 0?l.path=s+"."+l.path:l.path=s,t.append&&(l.message=`${l.message} (${l.path})`),l}},w.validateArg=function(a,s,t){let{assert:l,message:r}=t;if(w.isSchema(l)){const i=l.validate(a);return i.error?i.error.message:void 0}if(!l(a))return s?`${s} ${r}`:r},w.verifyFlat=function(a,s){for(const t of a)o(!Array.isArray(t),"Method no longer accepts array arguments:",s)}},3292:(S,w,b)=>{const o=b(375),v=b(8160),g=b(6133),f={};w.schema=function(e,n){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};v.assertOptions(a,["appendPath","override"]);try{return f.schema(e,n,a)}catch(s){throw a.appendPath&&s.path!==void 0&&(s.message=`${s.message} (${s.path})`),s}},f.schema=function(e,n,a){o(n!==void 0,"Invalid undefined schema"),Array.isArray(n)&&(o(n.length,"Invalid empty array schema"),n.length===1&&(n=n[0]));const s=D(function(t){for(var l=arguments.length,r=new Array(l>1?l-1:0),i=1;i<l;i++)r[i-1]=arguments[i];return a.override!==!1?t.valid(e.override,...r):t.valid(...r)},"a");if(f.simple(n))return s(e,n);if(typeof n=="function")return e.custom(n);if(o(typeof n=="object","Invalid schema content:",typeof n),v.isResolvable(n))return s(e,n);if(v.isSchema(n))return n;if(Array.isArray(n)){for(const t of n)if(!f.simple(t))return e.alternatives().try(...n);return s(e,...n)}return n instanceof RegExp?e.string().regex(n):n instanceof Date?s(e.date(),n):(o(Object.getPrototypeOf(n)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),e.object().keys(n))},w.ref=function(e,n){return g.isRef(e)?e:g.create(e,n)},w.compile=function(e,n){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};v.assertOptions(a,["legacy"]);const s=n&&n[v.symbols.any];if(s)return o(a.legacy||s.version===v.version,"Cannot mix different versions of joi schemas:",s.version,v.version),n;if(typeof n!="object"||!a.legacy)return w.schema(e,n,{appendPath:!0});const t=f.walk(n);return t?t.compile(t.root,n):w.schema(e,n,{appendPath:!0})},f.walk=function(e){if(typeof e!="object")return null;if(Array.isArray(e)){for(const a of e){const s=f.walk(a);if(s)return s}return null}const n=e[v.symbols.any];if(n)return{root:e[n.root],compile:n.compile};o(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const a in e){const s=f.walk(e[a]);if(s)return s}return null},f.simple=function(e){return e===null||["boolean","string","number"].includes(typeof e)},w.when=function(e,n,a){if(a===void 0&&(o(n&&typeof n=="object","Missing options"),a=n,n=g.create(".")),Array.isArray(a)&&(a={switch:a}),v.assertOptions(a,["is","not","then","otherwise","switch","break"]),v.isSchema(n))return o(a.is===void 0,'"is" can not be used with a schema condition'),o(a.not===void 0,'"not" can not be used with a schema condition'),o(a.switch===void 0,'"switch" can not be used with a schema condition'),f.condition(e,{is:n,then:a.then,otherwise:a.otherwise,break:a.break});if(o(g.isRef(n)||typeof n=="string","Invalid condition:",n),o(a.not===void 0||a.is===void 0,'Cannot combine "is" with "not"'),a.switch===void 0){let t=a;a.not!==void 0&&(t={is:a.not,then:a.otherwise,otherwise:a.then,break:a.break});let l=t.is!==void 0?e.$_compile(t.is):e.$_root.invalid(null,!1,0,"").required();return o(t.then!==void 0||t.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),o(t.break===void 0||t.then===void 0||t.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),a.is===void 0||g.isRef(a.is)||v.isSchema(a.is)||(l=l.required()),f.condition(e,{ref:w.ref(n),is:l,then:t.then,otherwise:t.otherwise,break:t.break})}o(Array.isArray(a.switch),'"switch" must be an array'),o(a.is===void 0,'Cannot combine "switch" with "is"'),o(a.not===void 0,'Cannot combine "switch" with "not"'),o(a.then===void 0,'Cannot combine "switch" with "then"');const s={ref:w.ref(n),switch:[],break:a.break};for(let t=0;t<a.switch.length;++t){const l=a.switch[t],r=t===a.switch.length-1;v.assertOptions(l,r?["is","then","otherwise"]:["is","then"]),o(l.is!==void 0,'Switch statement missing "is"'),o(l.then!==void 0,'Switch statement missing "then"');const i={is:e.$_compile(l.is),then:e.$_compile(l.then)};if(g.isRef(l.is)||v.isSchema(l.is)||(i.is=i.is.required()),r){o(a.otherwise===void 0||l.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const c=a.otherwise!==void 0?a.otherwise:l.otherwise;c!==void 0&&(o(s.break===void 0,"Cannot specify both otherwise and break"),i.otherwise=e.$_compile(c))}s.switch.push(i)}return s},f.condition=function(e,n){for(const a of["then","otherwise"])n[a]===void 0?delete n[a]:n[a]=e.$_compile(n[a]);return n}},6354:(S,w,b)=>{const o=b(5688),v=b(8160),g=b(3328);w.Report=class{constructor(f,e,n,a,s,t,l){if(this.code=f,this.flags=a,this.messages=s,this.path=t.path,this.prefs=l,this.state=t,this.value=e,this.message=null,this.template=null,this.local=n||{},this.local.label=w.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const r=this.path[this.path.length-1];typeof r!="object"&&(this.local.key=r)}}_setTemplate(f){if(this.template=f,!this.flags.label&&this.path.length===0){const e=this._template(this.template,"root");e&&(this.local.label=e)}}toString(){if(this.message)return this.message;const f=this.code;if(!this.prefs.errors.render)return this.code;const e=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return e===void 0?`Error code "${f}" is not defined, your custom type is missing the correct messages definition`:(this.message=e.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(f,e){return w.template(this.value,f,e||this.code,this.state,this.prefs)}},w.path=function(f){let e="";for(const n of f)typeof n!="object"&&(typeof n=="string"?(e&&(e+="."),e+=n):e+=`[${n}]`);return e},w.template=function(f,e,n,a,s){if(!e)return;if(g.isTemplate(e))return n!=="root"?e:null;let t=s.errors.language;if(v.isResolvable(t)&&(t=t.resolve(f,a,s)),t&&e[t]){if(e[t][n]!==void 0)return e[t][n];if(e[t]["*"]!==void 0)return e[t]["*"]}return e[n]?e[n]:e["*"]},w.label=function(f,e,n,a){if(f.label)return f.label;if(!n.errors.label)return"";let s=e.path;return n.errors.label==="key"&&e.path.length>1&&(s=e.path.slice(-1)),w.path(s)||w.template(null,n.messages,"root",e,n)||a&&w.template(null,a,"root",e,n)||"value"},w.process=function(f,e,n){if(!f)return null;const{override:a,message:s,details:t}=w.details(f);if(a)return a;if(n.errors.stack)return new w.ValidationError(s,t,e);const l=Error.stackTraceLimit;Error.stackTraceLimit=0;const r=new w.ValidationError(s,t,e);return Error.stackTraceLimit=l,r},w.details=function(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},n=[];const a=[];for(const s of f){if(s instanceof Error){if(e.override!==!1)return{override:s};const l=s.toString();n.push(l),a.push({message:l,type:"override",context:{error:s}});continue}const t=s.toString();n.push(t),a.push({message:t,path:s.path.filter(l=>typeof l!="object"),type:s.code,context:s.local})}return n.length>1&&(n=[...new Set(n)]),{message:n.join(". "),details:a}},w.ValidationError=class extends Error{constructor(f,e,n){super(f),this._original=n,this.details=e}static isError(f){return f instanceof w.ValidationError}},w.ValidationError.prototype.isJoi=!0,w.ValidationError.prototype.name="ValidationError",w.ValidationError.prototype.annotate=o.error},8901:(S,w,b)=>{const o=b(375),v=b(8571),g=b(8160),f=b(6914),e={};w.type=function(n,a){const s=Object.getPrototypeOf(n),t=v(s),l=n._assign(Object.create(t)),r=Object.assign({},a);delete r.base,t._definition=r;const i=s._definition||{};r.messages=f.merge(i.messages,r.messages),r.properties=Object.assign({},i.properties,r.properties),l.type=r.type,r.flags=Object.assign({},i.flags,r.flags);const c=Object.assign({},i.terms);if(r.terms)for(const _ in r.terms){const u=r.terms[_];o(l.$_terms[_]===void 0,"Invalid term override for",r.type,_),l.$_terms[_]=u.init,c[_]=u}r.terms=c,r.args||(r.args=i.args),r.prepare=e.prepare(r.prepare,i.prepare),r.coerce&&(typeof r.coerce=="function"&&(r.coerce={method:r.coerce}),r.coerce.from&&!Array.isArray(r.coerce.from)&&(r.coerce={method:r.coerce.method,from:[].concat(r.coerce.from)})),r.coerce=e.coerce(r.coerce,i.coerce),r.validate=e.validate(r.validate,i.validate);const d=Object.assign({},i.rules);if(r.rules)for(const _ in r.rules){const u=r.rules[_];o(typeof u=="object","Invalid rule definition for",r.type,_);let m=u.method;if(m===void 0&&(m=D(function(){return this.$_addRule(_)},"r")),m&&(o(!t[_],"Rule conflict in",r.type,_),t[_]=m),o(!d[_],"Rule conflict in",r.type,_),d[_]=u,u.alias){const h=[].concat(u.alias);for(const $ of h)t[$]=u.method}u.args&&(u.argsByName=new Map,u.args=u.args.map(h=>(typeof h=="string"&&(h={name:h}),o(!u.argsByName.has(h.name),"Duplicated argument name",h.name),g.isSchema(h.assert)&&(h.assert=h.assert.strict().label(h.name)),u.argsByName.set(h.name,h),h)))}r.rules=d;const y=Object.assign({},i.modifiers);if(r.modifiers)for(const _ in r.modifiers){o(!t[_],"Rule conflict in",r.type,_);const u=r.modifiers[_];o(typeof u=="function","Invalid modifier definition for",r.type,_);const m=D(function(h){return this.rule({[_]:h})},"r");t[_]=m,y[_]=u}if(r.modifiers=y,r.overrides){t._super=s,l.$_super={};for(const _ in r.overrides)o(s[_],"Cannot override missing",_),r.overrides[_][g.symbols.parent]=s[_],l.$_super[_]=s[_].bind(l);Object.assign(t,r.overrides)}r.cast=Object.assign({},i.cast,r.cast);const x=Object.assign({},i.manifest,r.manifest);return x.build=e.build(r.manifest&&r.manifest.build,i.manifest&&i.manifest.build),r.manifest=x,r.rebuild=e.rebuild(r.rebuild,i.rebuild),l},e.build=function(n,a){return n&&a?function(s,t){return a(n(s,t),t)}:n||a},e.coerce=function(n,a){return n&&a?{from:n.from&&a.from?[...new Set([...n.from,...a.from])]:null,method(s,t){let l;if((!a.from||a.from.includes(typeof s))&&(l=a.method(s,t),l)){if(l.errors||l.value===void 0)return l;s=l.value}if(!n.from||n.from.includes(typeof s)){const r=n.method(s,t);if(r)return r}return l}}:n||a},e.prepare=function(n,a){return n&&a?function(s,t){const l=n(s,t);if(l){if(l.errors||l.value===void 0)return l;s=l.value}return a(s,t)||l}:n||a},e.rebuild=function(n,a){return n&&a?function(s){a(s),n(s)}:n||a},e.validate=function(n,a){return n&&a?function(s,t){const l=a(s,t);if(l){if(l.errors&&(!Array.isArray(l.errors)||l.errors.length))return l;s=l.value}return n(s,t)||l}:n||a}},5107:(S,w,b)=>{const o=b(375),v=b(8571),g=b(8652),f=b(8160),e=b(3292),n=b(6354),a=b(8901),s=b(9708),t=b(6133),l=b(3328),r=b(1152);let i;const c={types:{alternatives:b(4946),any:b(8068),array:b(546),boolean:b(4937),date:b(7500),function:b(390),link:b(8785),number:b(3832),object:b(8966),string:b(7417),symbol:b(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const d={_types:new Set(Object.keys(c.types))};for(const y of d._types)d[y]=function(){for(var x=arguments.length,_=new Array(x),u=0;u<x;u++)_[u]=arguments[u];return o(!_.length||["alternatives","link","object"].includes(y),"The",y,"type does not allow arguments"),c.generate(this,c.types[y],_)};for(const y of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])d[y]=function(){return this.any()[y](...arguments)};Object.assign(d,c.methods);for(const y in c.aliases){const x=c.aliases[y];d[y]=d[x]}return d.x=d.expression,r.setup&&r.setup(d),d}};c.methods={ValidationError:n.ValidationError,version:f.version,cache:g.provider,assert(d,y){for(var x=arguments.length,_=new Array(x>2?x-2:0),u=2;u<x;u++)_[u-2]=arguments[u];c.assert(d,y,!0,_)},attempt(d,y){for(var x=arguments.length,_=new Array(x>2?x-2:0),u=2;u<x;u++)_[u-2]=arguments[u];return c.assert(d,y,!1,_)},build(d){return o(typeof s.build=="function","Manifest functionality disabled"),s.build(this,d)},checkPreferences(d){f.checkPreferences(d)},compile(d,y){return e.compile(this,d,y)},defaults(d){o(typeof d=="function","modifier must be a function");const y=Object.assign({},this);for(const x of y._types){const _=d(y[x]());o(f.isSchema(_),"modifier must return a valid schema object"),y[x]=function(){for(var u=arguments.length,m=new Array(u),h=0;h<u;h++)m[h]=arguments[h];return c.generate(this,_,m)}}return y},expression(){for(var d=arguments.length,y=new Array(d),x=0;x<d;x++)y[x]=arguments[x];return new l(...y)},extend(){for(var d=arguments.length,y=new Array(d),x=0;x<d;x++)y[x]=arguments[x];f.verifyFlat(y,"extend"),i=i||b(3378),o(y.length,"You need to provide at least one extension"),this.assert(y,i.extensions);const _=Object.assign({},this);_._types=new Set(_._types);for(let u of y){typeof u=="function"&&(u=u(_)),this.assert(u,i.extension);const m=c.expandExtension(u,_);for(const h of m){o(_[h.type]===void 0||_._types.has(h.type),"Cannot override name",h.type);const $=h.base||this.any(),j=a.type($,h);_._types.add(h.type),_[h.type]=function(){for(var E=arguments.length,N=new Array(E),M=0;M<E;M++)N[M]=arguments[M];return c.generate(this,j,N)}}}return _},isError:n.ValidationError.isError,isExpression:l.isTemplate,isRef:t.isRef,isSchema:f.isSchema,in(){return t.in(...arguments)},override:f.symbols.override,ref(){return t.create(...arguments)},types(){const d={};for(const y of this._types)d[y]=this[y]();for(const y in c.aliases)d[y]=this[y]();return d}},c.assert=function(d,y,x,_){const u=_[0]instanceof Error||typeof _[0]=="string"?_[0]:null,m=u!==null?_[1]:_[0],h=y.validate(d,f.preferences({errors:{stack:!0}},m||{}));let $=h.error;if(!$)return h.value;if(u instanceof Error)throw u;const j=x&&typeof $.annotate=="function"?$.annotate():$.message;throw $ instanceof n.ValidationError==0&&($=v($)),$.message=u?`${u} ${j}`:j,$},c.generate=function(d,y,x){return o(d,"Must be invoked on a Joi instance."),y.$_root=d,y._definition.args&&x.length?y._definition.args(y,...x):y},c.expandExtension=function(d,y){if(typeof d.type=="string")return[d];const x=[];for(const _ of y._types)if(d.type.test(_)){const u=Object.assign({},d);u.type=_,u.base=y[_](),x.push(u)}return x},S.exports=c.root()},6914:(S,w,b)=>{const o=b(375),v=b(8571),g=b(3328);w.compile=function(f,e){if(typeof f=="string")return o(!e,"Cannot set single message string"),new g(f);if(g.isTemplate(f))return o(!e,"Cannot set single message template"),f;o(typeof f=="object"&&!Array.isArray(f),"Invalid message options"),e=e?v(e):{};for(let n in f){const a=f[n];if(n==="root"||g.isTemplate(a)){e[n]=a;continue}if(typeof a=="string"){e[n]=new g(a);continue}o(typeof a=="object"&&!Array.isArray(a),"Invalid message for",n);const s=n;for(n in e[s]=e[s]||{},a){const t=a[n];n==="root"||g.isTemplate(t)?e[s][n]=t:(o(typeof t=="string","Invalid message for",n,"in",s),e[s][n]=new g(t))}}return e},w.decompile=function(f){const e={};for(let n in f){const a=f[n];if(n==="root"){e.root=a;continue}if(g.isTemplate(a)){e[n]=a.describe({compact:!0});continue}const s=n;for(n in e[s]={},a){const t=a[n];n!=="root"?e[s][n]=t.describe({compact:!0}):e[s].root=t}}return e},w.merge=function(f,e){if(!f)return w.compile(e);if(!e)return f;if(typeof e=="string")return new g(e);if(g.isTemplate(e))return e;const n=v(f);for(let a in e){const s=e[a];if(a==="root"||g.isTemplate(s)){n[a]=s;continue}if(typeof s=="string"){n[a]=new g(s);continue}o(typeof s=="object"&&!Array.isArray(s),"Invalid message for",a);const t=a;for(a in n[t]=n[t]||{},s){const l=s[a];a==="root"||g.isTemplate(l)?n[t][a]=l:(o(typeof l=="string","Invalid message for",a,"in",t),n[t][a]=new g(l))}}return n}},2294:(S,w,b)=>{const o=b(375),v=b(8160),g=b(6133),f={};w.Ids=f.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const e=new f.Ids;return e._byId=new Map(this._byId),e._byKey=new Map(this._byKey),e._schemaChain=this._schemaChain,e}concat(e){e._schemaChain&&(this._schemaChain=!0);for(const[n,a]of e._byId.entries())o(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,a);for(const[n,a]of e._byKey.entries())o(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,a)}fork(e,n,a){const s=this._collect(e);s.push({schema:a});const t=s.shift();let l={id:t.id,schema:n(t.schema)};o(v.isSchema(l.schema),"adjuster function failed to return a joi schema type");for(const r of s)l={id:r.id,schema:f.fork(r.schema,l.id,l.schema)};return l.schema}labels(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const a=e[0],s=this._get(a);if(!s)return[...n,...e].join(".");const t=e.slice(1);return n=[...n,s.schema._flags.label||a],t.length?s.schema._ids.labels(t,n):n.join(".")}reach(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const a=e[0],s=this._get(a);o(s,"Schema does not contain path",[...n,...e].join("."));const t=e.slice(1);return t.length?s.schema._ids.reach(t,[...n,a]):s.schema}register(e){let{key:n}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!e||!v.isSchema(e))return;(e.$_property("schemaChain")||e._ids._schemaChain)&&(this._schemaChain=!0);const a=e._flags.id;if(a){const s=this._byId.get(a);o(!s||s.schema===e,"Cannot add different schemas with the same id:",a),o(!this._byKey.has(a),"Schema id conflicts with existing key:",a),this._byId.set(a,{schema:e,id:a})}n&&(o(!this._byKey.has(n),"Schema already contains key:",n),o(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,{schema:e,id:n}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[];const s=e[0],t=this._get(s);o(t,"Schema does not contain path",[...n,...e].join(".")),a=[t,...a];const l=e.slice(1);return l.length?t.schema._ids._collect(l,[...n,s],a):a}_get(e){return this._byId.get(e)||this._byKey.get(e)}},f.fork=function(e,n,a){const s=w.schema(e,{each:(t,l)=>{let{key:r}=l;if(n===(t._flags.id||r))return a},ref:!1});return s?s.$_mutateRebuild():e},w.schema=function(e,n){let a;for(const s in e._flags){if(s[0]==="_")continue;const t=f.scan(e._flags[s],{source:"flags",name:s},n);t!==void 0&&(a=a||e.clone(),a._flags[s]=t)}for(let s=0;s<e._rules.length;++s){const t=e._rules[s],l=f.scan(t.args,{source:"rules",name:t.name},n);if(l!==void 0){a=a||e.clone();const r=Object.assign({},t);r.args=l,a._rules[s]=r,a._singleRules.get(t.name)===t&&a._singleRules.set(t.name,r)}}for(const s in e.$_terms){if(s[0]==="_")continue;const t=f.scan(e.$_terms[s],{source:"terms",name:s},n);t!==void 0&&(a=a||e.clone(),a.$_terms[s]=t)}return a},f.scan=function(e,n,a,s,t){const l=s||[];if(e===null||typeof e!="object")return;let r;if(Array.isArray(e)){for(let i=0;i<e.length;++i){const c=n.source==="terms"&&n.name==="keys"&&e[i].key,d=f.scan(e[i],n,a,[i,...l],c);d!==void 0&&(r=r||e.slice(),r[i]=d)}return r}if(a.schema!==!1&&v.isSchema(e)||a.ref!==!1&&g.isRef(e)){const i=a.each(e,{...n,path:l,key:t});return i===e?void 0:i}for(const i in e){if(i[0]==="_")continue;const c=f.scan(e[i],n,a,[i,...l],t);c!==void 0&&(r=r||Object.assign({},e),r[i]=c)}return r}},6133:(S,w,b)=>{const o=b(375),v=b(8571),g=b(9621),f=b(8160);let e;const n={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};w.create=function(a){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};o(typeof a=="string","Invalid reference key:",a),f.assertOptions(s,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),o(!s.prefix||typeof s.prefix=="object","options.prefix must be of type object");const t=Object.assign({},n.defaults,s);delete t.prefix;const l=t.separator,r=n.context(a,l,s.prefix);if(t.type=r.type,a=r.key,t.type==="value")if(r.root&&(o(!l||a[0]!==l,"Cannot specify relative path with root prefix"),t.ancestor="root",a||(a=null)),l&&l===a)a=null,t.ancestor=0;else if(t.ancestor!==void 0)o(!l||!a||a[0]!==l,"Cannot combine prefix with ancestor option");else{const[i,c]=n.ancestor(a,l);c&&(a=a.slice(c))===""&&(a=null),t.ancestor=i}return t.path=l?a===null?[]:a.split(l):[a],new n.Ref(t)},w.in=function(a){let s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return w.create(a,{...s,in:!0})},w.isRef=function(a){return!!a&&!!a[f.symbols.ref]},n.Ref=class{constructor(a){o(typeof a=="object","Invalid reference construction"),f.assertOptions(a,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),o([!1,void 0].includes(a.separator)||typeof a.separator=="string"&&a.separator.length===1,"Invalid separator"),o(!a.adjust||typeof a.adjust=="function","options.adjust must be a function"),o(!a.map||Array.isArray(a.map),"options.map must be an array"),o(!a.map||!a.adjust,"Cannot set both map and adjust options"),Object.assign(this,n.defaults,a),o(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(a,s,t,l){let r=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};return o(!this.in||r.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(t.context,s,r):this.type==="local"?this._resolve(l,s,r):this.ancestor?this.ancestor==="root"?this._resolve(s.ancestors[s.ancestors.length-1],s,r):(o(this.ancestor<=s.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(s.ancestors[this.ancestor-1],s,r)):this._resolve(a,s,r)}_resolve(a,s,t){let l;if(this.type==="value"&&s.mainstay.shadow&&t.shadow!==!1&&(l=s.mainstay.shadow.get(this.absolute(s))),l===void 0&&(l=g(a,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(l=this.adjust(l)),this.map){const r=this.map.get(l);r!==void 0&&(l=r)}return s.mainstay&&s.mainstay.tracer.resolve(s,this,l),l}toString(){return this.display}absolute(a){return[...a.path.slice(0,-this.ancestor),...this.path]}clone(){return new n.Ref(this)}describe(){const a={path:this.path};this.type!=="value"&&(a.type=this.type),this.separator!=="."&&(a.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(a.ancestor=this.ancestor),this.map&&(a.map=[...this.map]);for(const s of["adjust","iterables","render"])this[s]!==null&&this[s]!==void 0&&(a[s]=this[s]);return this.in!==!1&&(a.in=!0),{ref:a}}updateDisplay(){const a=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display=`ref:${this.type}:${a}`);if(!this.separator)return void(this.display=`ref:${a}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${a}`);if(this.ancestor==="root")return void(this.display=`ref:root:${a}`);if(this.ancestor===1)return void(this.display=`ref:${a||".."}`);const s=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${s}${a||""}`}},n.Ref.prototype[f.symbols.ref]=!0,w.build=function(a){return(a=Object.assign({},n.defaults,a)).type==="value"&&a.ancestor===void 0&&(a.ancestor=1),new n.Ref(a)},n.context=function(a,s){let t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(a=a.trim(),t){const l=t.global===void 0?"$":t.global;if(l!==s&&a.startsWith(l))return{key:a.slice(l.length),type:"global"};const r=t.local===void 0?"#":t.local;if(r!==s&&a.startsWith(r))return{key:a.slice(r.length),type:"local"};const i=t.root===void 0?"/":t.root;if(i!==s&&a.startsWith(i))return{key:a.slice(i.length),type:"value",root:!0}}return{key:a,type:"value"}},n.ancestor=function(a,s){if(!s)return[1,0];if(a[0]!==s)return[1,0];if(a[1]!==s)return[0,1];let t=2;for(;a[t]===s;)++t;return[t-1,t]},w.toSibling=0,w.toParent=1,w.Manager=class{constructor(){this.refs=[]}register(a,s){if(a)if(s=s===void 0?w.toParent:s,Array.isArray(a))for(const t of a)this.register(t,s);else if(f.isSchema(a))for(const t of a._refs.refs)t.ancestor-s>=0&&this.refs.push({ancestor:t.ancestor-s,root:t.root});else w.isRef(a)&&a.type==="value"&&a.ancestor-s>=0&&this.refs.push({ancestor:a.ancestor-s,root:a.root}),e=e||b(3328),e.isTemplate(a)&&this.register(a.refs(),s)}get length(){return this.refs.length}clone(){const a=new w.Manager;return a.refs=v(this.refs),a}reset(){this.refs=[]}roots(){return this.refs.filter(a=>!a.ancestor).map(a=>a.root)}}},3378:(S,w,b)=>{const o=b(5107),v={};v.wrap=o.string().min(1).max(2).allow(!1),w.preferences=o.object({allowUnknown:o.boolean(),abortEarly:o.boolean(),artifacts:o.boolean(),cache:o.boolean(),context:o.object(),convert:o.boolean(),dateFormat:o.valid("date","iso","string","time","utc"),debug:o.boolean(),errors:{escapeHtml:o.boolean(),label:o.valid("path","key",!1),language:[o.string(),o.object().ref()],render:o.boolean(),stack:o.boolean(),wrap:{label:v.wrap,array:v.wrap,string:v.wrap}},externals:o.boolean(),messages:o.object(),noDefaults:o.boolean(),nonEnumerables:o.boolean(),presence:o.valid("required","optional","forbidden"),skipFunctions:o.boolean(),stripUnknown:o.object({arrays:o.boolean(),objects:o.boolean()}).or("arrays","objects").allow(!0,!1),warnings:o.boolean()}).strict(),v.nameRx=/^[a-zA-Z0-9]\w*$/,v.rule=o.object({alias:o.array().items(o.string().pattern(v.nameRx)).single(),args:o.array().items(o.string(),o.object({name:o.string().pattern(v.nameRx).required(),ref:o.boolean(),assert:o.alternatives([o.function(),o.object().schema()]).conditional("ref",{is:!0,then:o.required()}),normalize:o.function(),message:o.string().when("assert",{is:o.function(),then:o.required()})})),convert:o.boolean(),manifest:o.boolean(),method:o.function().allow(!1),multi:o.boolean(),validate:o.function()}),w.extension=o.object({type:o.alternatives([o.string(),o.object().regex()]).required(),args:o.function(),cast:o.object().pattern(v.nameRx,o.object({from:o.function().maxArity(1).required(),to:o.function().minArity(1).maxArity(2).required()})),base:o.object().schema().when("type",{is:o.object().regex(),then:o.forbidden()}),coerce:[o.function().maxArity(3),o.object({method:o.function().maxArity(3).required(),from:o.array().items(o.string()).single()})],flags:o.object().pattern(v.nameRx,o.object({setter:o.string(),default:o.any()})),manifest:{build:o.function().arity(2)},messages:[o.object(),o.string()],modifiers:o.object().pattern(v.nameRx,o.function().minArity(1).maxArity(2)),overrides:o.object().pattern(v.nameRx,o.function()),prepare:o.function().maxArity(3),rebuild:o.function().arity(1),rules:o.object().pattern(v.nameRx,v.rule),terms:o.object().pattern(v.nameRx,o.object({init:o.array().allow(null).required(),manifest:o.object().pattern(/.+/,[o.valid("schema","single"),o.object({mapped:o.object({from:o.string().required(),to:o.string().required()}).required()})])})),validate:o.function().maxArity(3)}).strict(),w.extensions=o.array().items(o.object(),o.function().arity(1)).strict(),v.desc={buffer:o.object({buffer:o.string()}),func:o.object({function:o.function().required(),options:{literal:!0}}),override:o.object({override:!0}),ref:o.object({ref:o.object({type:o.valid("value","global","local"),path:o.array().required(),separator:o.string().length(1).allow(!1),ancestor:o.number().min(0).integer().allow("root"),map:o.array().items(o.array().length(2)).min(1),adjust:o.function(),iterables:o.boolean(),in:o.boolean(),render:o.boolean()}).required()}),regex:o.object({regex:o.string().min(3)}),special:o.object({special:o.valid("deep").required()}),template:o.object({template:o.string().required(),options:o.object()}),value:o.object({value:o.alternatives([o.object(),o.array()]).required()})},v.desc.entity=o.alternatives([o.array().items(o.link("...")),o.boolean(),o.function(),o.number(),o.string(),v.desc.buffer,v.desc.func,v.desc.ref,v.desc.regex,v.desc.special,v.desc.template,v.desc.value,o.link("/")]),v.desc.values=o.array().items(null,o.boolean(),o.function(),o.number().allow(1/0,-1/0),o.string().allow(""),o.symbol(),v.desc.buffer,v.desc.func,v.desc.override,v.desc.ref,v.desc.regex,v.desc.template,v.desc.value),v.desc.messages=o.object().pattern(/.+/,[o.string(),v.desc.template,o.object().pattern(/.+/,[o.string(),v.desc.template])]),w.description=o.object({type:o.string().required(),flags:o.object({cast:o.string(),default:o.any(),description:o.string(),empty:o.link("/"),failover:v.desc.entity,id:o.string(),label:o.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:o.boolean(),unit:o.string()}).unknown(),preferences:{allowUnknown:o.boolean(),abortEarly:o.boolean(),artifacts:o.boolean(),cache:o.boolean(),convert:o.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:o.boolean(),label:["path","key"],language:[o.string(),v.desc.ref],wrap:{label:v.wrap,array:v.wrap}},externals:o.boolean(),messages:v.desc.messages,noDefaults:o.boolean(),nonEnumerables:o.boolean(),presence:["required","optional","forbidden"],skipFunctions:o.boolean(),stripUnknown:o.object({arrays:o.boolean(),objects:o.boolean()}).or("arrays","objects").allow(!0,!1),warnings:o.boolean()},allow:v.desc.values,invalid:v.desc.values,rules:o.array().min(1).items({name:o.string().required(),args:o.object().min(1),keep:o.boolean(),message:[o.string(),v.desc.messages],warn:o.boolean()}),keys:o.object().pattern(/.*/,o.link("/")),link:v.desc.ref}).pattern(/^[a-z]\w*$/,o.any())},493:(S,w,b)=>{const o=b(8571),v=b(9621),g=b(8160),f={value:Symbol("value")};S.exports=f.State=class{constructor(e,n,a){this.path=e,this.ancestors=n,this.mainstay=a.mainstay,this.schemas=a.schemas,this.debug=null}localize(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null,a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;const s=new f.State(e,n,this);return a&&s.schemas&&(s.schemas=[f.schemas(a),...s.schemas]),s}nest(e,n){const a=new f.State(this.path,this.ancestors,this);return a.schemas=a.schemas&&[f.schemas(e),...a.schemas],a.debug=n,a}shadow(e,n){this.mainstay.shadow=this.mainstay.shadow||new f.Shadow,this.mainstay.shadow.set(this.path,e,n)}snapshot(){this.mainstay.shadow&&(this._snapshot=o(this.mainstay.shadow.node(this.path)))}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0)}},f.schemas=function(e){return g.isSchema(e)?{schema:e}:e},f.Shadow=class{constructor(){this._values=null}set(e,n,a){if(!e.length||a==="strip"&&typeof e[e.length-1]=="number")return;this._values=this._values||new Map;let s=this._values;for(let t=0;t<e.length;++t){const l=e[t];let r=s.get(l);r||(r=new Map,s.set(l,r)),s=r}s[f.value]=n}get(e){const n=this.node(e);if(n)return n[f.value]}node(e){if(this._values)return v(this._values,e,{iterables:!0})}override(e,n){if(!this._values)return;const a=e.slice(0,-1),s=e[e.length-1],t=v(this._values,a,{iterables:!0});n?t.set(s,n):t&&t.delete(s)}}},3328:(S,w,b)=>{const o=b(375),v=b(8571),g=b(5277),f=b(1447),e=b(8160),n=b(6354),a=b(6133),s={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};S.exports=s.Template=class{constructor(t,l){o(typeof t=="string","Template source must be a string"),o(!t.includes("\0")&&!t.includes(""),"Template source cannot contain reserved control characters"),this.source=t,this.rendered=t,this._template=null,this._settings=v(l),this._parse()}_parse(){if(!this.source.includes("{"))return;const t=s.encode(this.source),l=s.split(t);let r=!1;const i=[],c=l.shift();c&&i.push(c);for(const d of l){const y=d[0]!=="{",x=y?"}":"}}",_=d.indexOf(x);if(_===-1||d[1]==="{"){i.push(`{${s.decode(d)}`);continue}let u=d.slice(y?0:1,_);const m=u[0]===":";m&&(u=u.slice(1));const h=this._ref(s.decode(u),{raw:y,wrapped:m});i.push(h),typeof h!="string"&&(r=!0);const $=d.slice(_+x.length);$&&i.push(s.decode($))}r?this._template=i:this.rendered=i.join("")}static date(t,l){return s.dateFormat[l.dateFormat].call(t)}describe(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(!this._settings&&t.compact)return this.source;const l={template:this.source};return this._settings&&(l.options=this._settings),l}static build(t){return new s.Template(t.template,t.options)}isDynamic(){return!!this._template}static isTemplate(t){return!!t&&!!t[e.symbols.template]}refs(){if(!this._template)return;const t=[];for(const l of this._template)typeof l!="string"&&t.push(...l.refs);return t}resolve(t,l,r,i){return this._template&&this._template.length===1?this._part(this._template[0],t,l,r,i,{}):this.render(t,l,r,i)}_part(t){for(var l=arguments.length,r=new Array(l>1?l-1:0),i=1;i<l;i++)r[i-1]=arguments[i];return t.ref?t.ref.resolve(...r):t.formula.evaluate(r)}render(t,l,r,i){let c=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};if(!this.isDynamic())return this.rendered;const d=[];for(const y of this._template)if(typeof y=="string")d.push(y);else{const x=this._part(y,t,l,r,i,c),_=s.stringify(x,t,l,r,i,c);if(_!==void 0){const u=y.raw||(c.errors&&c.errors.escapeHtml)===!1?_:g(_);d.push(s.wrap(u,y.wrapped&&r.errors.wrap.label))}}return d.join("")}_ref(t,l){let{raw:r,wrapped:i}=l;const c=[],d=D(x=>{const _=a.create(x,this._settings);return c.push(_),u=>_.resolve(...u)},"a");try{var y=new f.Parser(t,{reference:d,functions:s.functions,constants:s.constants})}catch(x){throw x.message=`Invalid template variable "${t}" fails due to: ${x.message}`,x}if(y.single){if(y.single.type==="reference"){const x=c[0];return{ref:x,raw:r,refs:c,wrapped:i||x.type==="local"&&x.key==="label"}}return s.stringify(y.single.value)}return{formula:y,raw:r,refs:c}}toString(){return this.source}},s.Template.prototype[e.symbols.template]=!0,s.Template.prototype.isImmutable=!0,s.encode=function(t){return t.replace(/\\(\{+)/g,(l,r)=>s.opens.slice(0,r.length)).replace(/\\(\}+)/g,(l,r)=>s.closes.slice(0,r.length))},s.decode=function(t){return t.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},s.split=function(t){const l=[];let r="";for(let i=0;i<t.length;++i){const c=t[i];if(c==="{"){let d="";for(;i+1<t.length&&t[i+1]==="{";)d+="{",++i;l.push(r),r=d}else r+=c}return l.push(r),l},s.wrap=function(t,l){return l?l.length===1?`${l}${t}${l}`:`${l[0]}${t}${l[1]}`:t},s.stringify=function(t,l,r,i,c){let d=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{};const y=typeof t,x=i&&i.errors&&i.errors.wrap||{};let _=!1;if(a.isRef(t)&&t.render&&(_=t.in,t=t.resolve(l,r,i,c,{in:t.in,...d})),t===null)return"null";if(y==="string")return s.wrap(t,d.arrayItems&&x.string);if(y==="number"||y==="function"||y==="symbol")return t.toString();if(y!=="object")return JSON.stringify(t);if(t instanceof Date)return s.Template.date(t,i);if(t instanceof Map){const m=[];for(const[h,$]of t.entries())m.push(`${h.toString()} -> ${$.toString()}`);t=m}if(!Array.isArray(t))return t.toString();const u=[];for(const m of t)u.push(s.stringify(m,l,r,i,c,{arrayItems:!0,...d}));return s.wrap(u.join(", "),!_&&x.array)},s.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},s.functions={if:(t,l,r)=>t?l:r,length:t=>typeof t=="string"?t.length:t&&typeof t=="object"?Array.isArray(t)?t.length:Object.keys(t).length:null,msg(t){const[l,r,i,c,d]=this,y=d.messages;if(!y)return"";const x=n.template(l,y[0],t,r,i)||n.template(l,y[1],t,r,i);return x?x.render(l,r,i,c,d):""},number:t=>typeof t=="number"?t:typeof t=="string"?parseFloat(t):typeof t=="boolean"?t?1:0:t instanceof Date?t.getTime():null}},4946:(S,w,b)=>{const o=b(375),v=b(1687),g=b(8068),f=b(8160),e=b(3292),n=b(6354),a=b(6133),s={};S.exports=g.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:a.toSibling}},args(t){for(var l=arguments.length,r=new Array(l>1?l-1:0),i=1;i<l;i++)r[i-1]=arguments[i];return r.length===1&&Array.isArray(r[0])?t.try(...r[0]):t.try(...r)},validate(t,l){const{schema:r,error:i,state:c,prefs:d}=l;if(r._flags.match){const x=[],_=[];for(let m=0;m<r.$_terms.matches.length;++m){const h=r.$_terms.matches[m],$=c.nest(h.schema,`match.${m}`);$.snapshot();const j=h.schema.$_validate(t,$,d);j.errors?(_.push(j.errors),$.restore()):x.push(j.value)}if(x.length===0)return{errors:i("alternatives.any",{details:_.map(m=>n.details(m,{override:!1}))})};if(r._flags.match==="one")return x.length===1?{value:x[0]}:{errors:i("alternatives.one")};if(x.length!==r.$_terms.matches.length)return{errors:i("alternatives.all",{details:_.map(m=>n.details(m,{override:!1}))})};const u=D(m=>m.$_terms.matches.some(h=>h.schema.type==="object"||h.schema.type==="alternatives"&&u(h.schema)),"c");return u(r)?{value:x.reduce((m,h)=>v(m,h,{mergeArrays:!1}))}:{value:x[x.length-1]}}const y=[];for(let x=0;x<r.$_terms.matches.length;++x){const _=r.$_terms.matches[x];if(_.schema){const h=c.nest(_.schema,`match.${x}`);h.snapshot();const $=_.schema.$_validate(t,h,d);if(!$.errors)return $;h.restore(),y.push({schema:_.schema,reports:$.errors});continue}const u=_.ref?_.ref.resolve(t,c,d):t,m=_.is?[_]:_.switch;for(let h=0;h<m.length;++h){const $=m[h],{is:j,then:E,otherwise:N}=$,M=`match.${x}${_.switch?"."+h:""}`;if(j.$_match(u,c.nest(j,`${M}.is`),d)){if(E)return E.$_validate(t,c.nest(E,`${M}.then`),d)}else if(N)return N.$_validate(t,c.nest(N,`${M}.otherwise`),d)}}return s.errors(y,l)},rules:{conditional:{method(t,l){o(!this._flags._endedSwitch,"Unreachable condition"),o(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),o(l.break===void 0,"Cannot use break option with alternatives conditional");const r=this.clone(),i=e.when(r,t,l),c=i.is?[i]:i.switch;for(const d of c)if(d.then&&d.otherwise){r.$_setFlag("_endedSwitch",!0,{clone:!1});break}return r.$_terms.matches.push(i),r.$_mutateRebuild()}},match:{method(t){if(o(["any","one","all"].includes(t),"Invalid alternatives match mode",t),t!=="any")for(const l of this.$_terms.matches)o(l.schema,"Cannot combine match mode",t,"with conditional rules");return this.$_setFlag("match",t)}},try:{method(){for(var t=arguments.length,l=new Array(t),r=0;r<t;r++)l[r]=arguments[r];o(l.length,"Missing alternative schemas"),f.verifyFlat(l,"try"),o(!this._flags._endedSwitch,"Unreachable condition");const i=this.clone();for(const c of l)i.$_terms.matches.push({schema:i.$_compile(c)});return i.$_mutateRebuild()}}},overrides:{label(t){return this.$_parent("label",t).$_modify({each:(l,r)=>r.path[0]!=="is"?l.label(t):void 0,ref:!1})}},rebuild(t){t.$_modify({each:l=>{f.isSchema(l)&&l.type==="array"&&t.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(t,l){if(l.matches)for(const r of l.matches){const{schema:i,ref:c,is:d,not:y,then:x,otherwise:_}=r;t=i?t.try(i):c?t.conditional(c,{is:d,then:x,not:y,otherwise:_,switch:r.switch}):t.conditional(d,{then:x,otherwise:_})}return t}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),s.errors=function(t,l){let{error:r,state:i}=l;if(!t.length)return{errors:r("alternatives.any")};if(t.length===1)return{errors:t[0].reports};const c=new Set,d=[];for(const{reports:y,schema:x}of t){if(y.length>1)return s.unmatched(t,r);const _=y[0];if(_ instanceof n.Report==0)return s.unmatched(t,r);if(_.state.path.length!==i.path.length){d.push({type:x.type,report:_});continue}if(_.code==="any.only"){for(const h of _.local.valids)c.add(h);continue}const[u,m]=_.code.split(".");m==="base"?c.add(u):d.push({type:x.type,report:_})}return d.length?d.length===1?{errors:d[0].report}:s.unmatched(t,r):{errors:r("alternatives.types",{types:[...c]})}},s.unmatched=function(t,l){const r=[];for(const i of t)r.push(...i.reports);return{errors:l("alternatives.match",n.details(r,{override:!1}))}}},8068:(S,w,b)=>{const o=b(375),v=b(7629),g=b(8160),f=b(6914);S.exports=v.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(e,n){return o(typeof e=="function","Method must be a function"),o(n===void 0||n&&typeof n=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:e,description:n}})},validate(e,n,a){let{method:s}=a;try{return s(e,n)}catch(t){return n.error("any.custom",{error:t})}},args:["method","description"],multi:!0},messages:{method(e){return this.prefs({messages:e})}},shared:{method(e){o(g.isSchema(e)&&e._flags.id,"Schema must be a schema with an id");const n=this.clone();return n.$_terms.shared=n.$_terms.shared||[],n.$_terms.shared.push(e),n.$_mutateRegister(e),n}},warning:{method(e,n){return o(e&&typeof e=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:e,local:n},warn:!0})},validate(e,n,a){let{code:s,local:t}=a;return n.error(s,t)},args:["code","local"],multi:!0}},modifiers:{keep(e){let n=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];e.keep=n},message(e,n){e.message=f.compile(n)},warn(e){let n=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];e.warn=n}},manifest:{build(e,n){for(const a in n){const s=n[a];if(["examples","externals","metas","notes","tags"].includes(a))for(const t of s)e=e[a.slice(0,-1)](t);else if(a!=="alterations")if(a!=="whens"){if(a==="shared")for(const t of s)e=e.shared(t)}else for(const t of s){const{ref:l,is:r,not:i,then:c,otherwise:d,concat:y}=t;e=y?e.concat(y):l?e.when(l,{is:r,not:i,then:c,otherwise:d,switch:t.switch,break:t.break}):e.when(r,{then:c,otherwise:d,break:t.break})}else{const t={};for(const{target:l,adjuster:r}of s)t[l]=r;e=e.alter(t)}}return e}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(S,w,b)=>{const o=b(375),v=b(9474),g=b(9621),f=b(8068),e=b(8160),n=b(3292),a={};S.exports=f.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(s,t){let{schema:l,state:r,prefs:i}=t;if(!Array.isArray(s))return;const c=l.$_getRule("sort");return c?a.sort(l,s,c.args.options,r,i):void 0}},validate(s,t){let{schema:l,error:r}=t;if(!Array.isArray(s)){if(l._flags.single){const i=[s];return i[e.symbols.arraySingle]=!0,{value:i}}return{errors:r("array.base")}}if(l.$_getRule("items")||l.$_terms.externals)return{value:s.slice()}},rules:{has:{method(s){s=this.$_compile(s,{appendPath:!0});const t=this.$_addRule({name:"has",args:{schema:s}});return t.$_mutateRegister(s),t},validate(s,t,l){let{state:r,prefs:i,error:c}=t,{schema:d}=l;const y=[s,...r.ancestors];for(let _=0;_<s.length;++_){const u=r.localize([...r.path,_],y,d);if(d.$_match(s[_],u,i))return s}const x=d._flags.label;return x?c("array.hasKnown",{patternLabel:x}):c("array.hasUnknown",null)},multi:!0},items:{method(){for(var s=arguments.length,t=new Array(s),l=0;l<s;l++)t[l]=arguments[l];e.verifyFlat(t,"items");const r=this.$_addRule("items");for(let i=0;i<t.length;++i){const c=e.tryWithPath(()=>this.$_compile(t[i]),i,{append:!0});r.$_terms.items.push(c)}return r.$_mutateRebuild()},validate(s,t){let{schema:l,error:r,state:i,prefs:c,errorsArray:d}=t;const y=l.$_terms._requireds.slice(),x=l.$_terms.ordered.slice(),_=[...l.$_terms._inclusions,...y],u=!s[e.symbols.arraySingle];delete s[e.symbols.arraySingle];const m=d();let h=s.length;for(let $=0;$<h;++$){const j=s[$];let E=!1,N=!1;const M=u?$:new Number($),V=[...i.path,M];if(!l._flags.sparse&&j===void 0){if(m.push(r("array.sparse",{key:M,path:V,pos:$,value:void 0},i.localize(V))),c.abortEarly)return m;x.shift();continue}const W=[s,...i.ancestors];for(const B of l.$_terms._exclusions)if(B.$_match(j,i.localize(V,W,B),c,{presence:"ignore"})){if(m.push(r("array.excludes",{pos:$,value:j},i.localize(V))),c.abortEarly)return m;E=!0,x.shift();break}if(E)continue;if(l.$_terms.ordered.length){if(x.length){const B=x.shift(),H=B.$_validate(j,i.localize(V,W,B),c);if(H.errors){if(m.push(...H.errors),c.abortEarly)return m}else if(B._flags.result==="strip")a.fastSplice(s,$),--$,--h;else{if(!l._flags.sparse&&H.value===void 0){if(m.push(r("array.sparse",{key:M,path:V,pos:$,value:void 0},i.localize(V))),c.abortEarly)return m;continue}s[$]=H.value}continue}if(!l.$_terms.items.length){if(m.push(r("array.orderedLength",{pos:$,limit:l.$_terms.ordered.length})),c.abortEarly)return m;break}}const K=[];let ne=y.length;for(let B=0;B<ne;++B){const H=i.localize(V,W,y[B]);H.snapshot();const te=y[B].$_validate(j,H,c);if(K[B]=te,!te.errors){if(s[$]=te.value,N=!0,a.fastSplice(y,B),--B,--ne,!l._flags.sparse&&te.value===void 0&&(m.push(r("array.sparse",{key:M,path:V,pos:$,value:void 0},i.localize(V))),c.abortEarly))return m;break}H.restore()}if(N)continue;const oe=c.stripUnknown&&!!c.stripUnknown.arrays||!1;ne=_.length;for(const B of _){let H;const te=y.indexOf(B);if(te!==-1)H=K[te];else{const ee=i.localize(V,W,B);if(ee.snapshot(),H=B.$_validate(j,ee,c),!H.errors){B._flags.result==="strip"?(a.fastSplice(s,$),--$,--h):l._flags.sparse||H.value!==void 0?s[$]=H.value:(m.push(r("array.sparse",{key:M,path:V,pos:$,value:void 0},i.localize(V))),E=!0),N=!0;break}ee.restore()}if(ne===1){if(oe){a.fastSplice(s,$),--$,--h,N=!0;break}if(m.push(...H.errors),c.abortEarly)return m;E=!0;break}}if(!E&&(l.$_terms._inclusions.length||l.$_terms._requireds.length)&&!N){if(oe){a.fastSplice(s,$),--$,--h;continue}if(m.push(r("array.includes",{pos:$,value:j},i.localize(V))),c.abortEarly)return m}}return y.length&&a.fillMissedErrors(l,m,y,s,i,c),x.length&&(a.fillOrderedErrors(l,m,x,s,i,c),m.length||a.fillDefault(x,s,i,c)),m.length?m:s},priority:!0,manifest:!1},length:{method(s){return this.$_addRule({name:"length",args:{limit:s},operator:"="})},validate(s,t,l,r){let{limit:i}=l,{name:c,operator:d,args:y}=r;return e.compare(s.length,i,d)?s:t.error("array."+c,{limit:y.limit,value:s})},args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"}]},max:{method(s){return this.$_addRule({name:"max",method:"length",args:{limit:s},operator:"<="})}},min:{method(s){return this.$_addRule({name:"min",method:"length",args:{limit:s},operator:">="})}},ordered:{method(){for(var s=arguments.length,t=new Array(s),l=0;l<s;l++)t[l]=arguments[l];e.verifyFlat(t,"ordered");const r=this.$_addRule("items");for(let i=0;i<t.length;++i){const c=e.tryWithPath(()=>this.$_compile(t[i]),i,{append:!0});a.validateSingle(c,r),r.$_mutateRegister(c),r.$_terms.ordered.push(c)}return r.$_mutateRebuild()}},single:{method(s){const t=s===void 0||!!s;return o(!t||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",t)}},sort:{method(){let s=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};e.assertOptions(s,["by","order"]);const t={order:s.order||"ascending"};return s.by&&(t.by=n.ref(s.by,{ancestor:0}),o(!t.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:t}})},validate(s,t,l){let{error:r,state:i,prefs:c,schema:d}=t,{options:y}=l;const{value:x,errors:_}=a.sort(d,s,y,i,c);if(_)return _;for(let u=0;u<s.length;++u)if(s[u]!==x[u])return r("array.sort",{order:y.order,by:y.by?y.by.key:"value"});return s},convert:!0},sparse:{method(s){const t=s===void 0||!!s;return this._flags.sparse===t?this:(t?this.clone():this.$_addRule("items")).$_setFlag("sparse",t,{clone:!1})}},unique:{method(s){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};o(!s||typeof s=="function"||typeof s=="string","comparator must be a function or a string"),e.assertOptions(t,["ignoreUndefined","separator"]);const l={name:"unique",args:{options:t,comparator:s}};if(s)if(typeof s=="string"){const r=e.default(t.separator,".");l.path=r?s.split(r):[s]}else l.comparator=s;return this.$_addRule(l)},validate(s,t,l,r){let{state:i,error:c,schema:d}=t,{comparator:y,options:x}=l,{comparator:_,path:u}=r;const m={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},h=_||v,$=x.ignoreUndefined;for(let j=0;j<s.length;++j){const E=u?g(s[j],u):s[j],N=_?m.custom:m[typeof E];if(o(N,"Failed to find unique map container for type",typeof E),N instanceof Map){const M=N.entries();let V;for(;!(V=M.next()).done;)if(h(V.value[0],E)){const W=i.localize([...i.path,j],[s,...i.ancestors]),K={pos:j,value:s[j],dupePos:V.value[1],dupeValue:s[V.value[1]]};return u&&(K.path=y),c("array.unique",K,W)}N.set(E,j)}else{if((!$||E!==void 0)&&N[E]!==void 0){const M={pos:j,value:s[j],dupePos:N[E],dupeValue:s[N[E]]};return u&&(M.path=y),c("array.unique",M,i.localize([...i.path,j],[s,...i.ancestors]))}N[E]=j}}return s},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(s,t)=>new Set(s)}},rebuild(s){s.$_terms._inclusions=[],s.$_terms._exclusions=[],s.$_terms._requireds=[];for(const t of s.$_terms.items)a.validateSingle(t,s),t._flags.presence==="required"?s.$_terms._requireds.push(t):t._flags.presence==="forbidden"?s.$_terms._exclusions.push(t):s.$_terms._inclusions.push(t);for(const t of s.$_terms.ordered)a.validateSingle(t,s)},manifest:{build:(s,t)=>(t.items&&(s=s.items(...t.items)),t.ordered&&(s=s.ordered(...t.ordered)),s)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),a.fillMissedErrors=function(s,t,l,r,i,c){const d=[];let y=0;for(const x of l){const _=x._flags.label;_?d.push(_):++y}d.length?y?t.push(s.$_createError("array.includesRequiredBoth",r,{knownMisses:d,unknownMisses:y},i,c)):t.push(s.$_createError("array.includesRequiredKnowns",r,{knownMisses:d},i,c)):t.push(s.$_createError("array.includesRequiredUnknowns",r,{unknownMisses:y},i,c))},a.fillOrderedErrors=function(s,t,l,r,i,c){const d=[];for(const y of l)y._flags.presence==="required"&&d.push(y);d.length&&a.fillMissedErrors(s,t,d,r,i,c)},a.fillDefault=function(s,t,l,r){const i=[];let c=!0;for(let d=s.length-1;d>=0;--d){const y=s[d],x=[t,...l.ancestors],_=y.$_validate(void 0,l.localize(l.path,x,y),r).value;if(c){if(_===void 0)continue;c=!1}i.unshift(_)}i.length&&t.push(...i)},a.fastSplice=function(s,t){let l=t;for(;l<s.length;)s[l++]=s[l];--s.length},a.validateSingle=function(s,t){(s.type==="array"||s._flags._arrayItems)&&(o(!t._flags.single,"Cannot specify array item with single rule enabled"),t.$_setFlag("_arrayItems",!0,{clone:!1}))},a.sort=function(s,t,l,r,i){const c=l.order==="ascending"?1:-1,d=-1*c,y=c,x=D((_,u)=>{let m=a.compare(_,u,d,y);if(m!==null||(l.by&&(_=l.by.resolve(_,r,i),u=l.by.resolve(u,r,i)),m=a.compare(_,u,d,y),m!==null))return m;const h=typeof _;if(h!==typeof u)throw s.$_createError("array.sort.mismatching",t,null,r,i);if(h!=="number"&&h!=="string")throw s.$_createError("array.sort.unsupported",t,{type:h},r,i);return h==="number"?(_-u)*c:_<u?d:y},"l");try{return{value:t.slice().sort(x)}}catch(_){return{errors:_}}},a.compare=function(s,t,l,r){return s===t?0:s===void 0?1:t===void 0?-1:s===null?r:t===null?l:null}},4937:(S,w,b)=>{const o=b(375),v=b(8068),g=b(8160),f=b(2036),e={isBool:function(n){return typeof n=="boolean"}};S.exports=v.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(n,a){let{schema:s}=a;if(typeof n!="boolean"){if(typeof n=="string"){const t=s._flags.sensitive?n:n.toLowerCase();n=t==="true"||t!=="false"&&n}return typeof n!="boolean"&&(n=s.$_terms.truthy&&s.$_terms.truthy.has(n,null,null,!s._flags.sensitive)||(!s.$_terms.falsy||!s.$_terms.falsy.has(n,null,null,!s._flags.sensitive))&&n),{value:n}}},validate(n,a){let{error:s}=a;if(typeof n!="boolean")return{value:n,errors:s("boolean.base")}},rules:{truthy:{method(){for(var n=arguments.length,a=new Array(n),s=0;s<n;s++)a[s]=arguments[s];g.verifyFlat(a,"truthy");const t=this.clone();t.$_terms.truthy=t.$_terms.truthy||new f;for(let l=0;l<a.length;++l){const r=a[l];o(r!==void 0,"Cannot call truthy with undefined"),t.$_terms.truthy.add(r)}return t}},falsy:{method(){for(var n=arguments.length,a=new Array(n),s=0;s<n;s++)a[s]=arguments[s];g.verifyFlat(a,"falsy");const t=this.clone();t.$_terms.falsy=t.$_terms.falsy||new f;for(let l=0;l<a.length;++l){const r=a[l];o(r!==void 0,"Cannot call falsy with undefined"),t.$_terms.falsy.add(r)}return t}},sensitive:{method(){let n=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("sensitive",n)}}},cast:{number:{from:e.isBool,to:(n,a)=>n?1:0},string:{from:e.isBool,to:(n,a)=>n?"true":"false"}},manifest:{build:(n,a)=>(a.truthy&&(n=n.truthy(...a.truthy)),a.falsy&&(n=n.falsy(...a.falsy)),n)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(S,w,b)=>{const o=b(375),v=b(8068),g=b(8160),f=b(3328),e={isDate:function(n){return n instanceof Date}};S.exports=v.extend({type:"date",coerce:{from:["number","string"],method(n,a){let{schema:s}=a;return{value:e.parse(n,s._flags.format)||n}}},validate(n,a){let{schema:s,error:t,prefs:l}=a;if(n instanceof Date&&!isNaN(n.getTime()))return;const r=s._flags.format;return l.convert&&r&&typeof n=="string"?{value:n,errors:t("date.format",{format:r})}:{value:n,errors:t("date.base")}},rules:{compare:{method:!1,validate(n,a,s,t){let{date:l}=s,{name:r,operator:i,args:c}=t;const d=l==="now"?Date.now():l.getTime();return g.compare(n.getTime(),d,i)?n:a.error("date."+r,{limit:c.date,value:n})},args:[{name:"date",ref:!0,normalize:n=>n==="now"?n:e.parse(n),assert:n=>n!==null,message:"must have a valid date format"}]},format:{method(n){return o(["iso","javascript","unix"].includes(n),"Unknown date format",n),this.$_setFlag("format",n)}},greater:{method(n){return this.$_addRule({name:"greater",method:"compare",args:{date:n},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(n){return this.$_addRule({name:"less",method:"compare",args:{date:n},operator:"<"})}},max:{method(n){return this.$_addRule({name:"max",method:"compare",args:{date:n},operator:"<="})}},min:{method(n){return this.$_addRule({name:"min",method:"compare",args:{date:n},operator:">="})}},timestamp:{method(){let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"javascript";return o(["javascript","unix"].includes(n),'"type" must be one of "javascript, unix"'),this.format(n)}}},cast:{number:{from:e.isDate,to:(n,a)=>n.getTime()},string:{from:e.isDate,to(n,a){let{prefs:s}=a;return f.date(n,s)}}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),e.parse=function(n,a){if(n instanceof Date)return n;if(typeof n!="string"&&(isNaN(n)||!isFinite(n))||/^\s*$/.test(n))return null;if(a==="iso")return g.isIsoDate(n)?e.date(n.toString()):null;const s=n;if(typeof n=="string"&&/^[+-]?\d+(\.\d+)?$/.test(n)&&(n=parseFloat(n)),a){if(a==="javascript")return e.date(1*n);if(a==="unix")return e.date(1e3*n);if(typeof s=="string")return null}return e.date(n)},e.date=function(n){const a=new Date(n);return isNaN(a.getTime())?null:a}},390:(S,w,b)=>{const o=b(375),v=b(7824);S.exports=v.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(g){return o(Number.isSafeInteger(g)&&g>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:g}})},validate(g,f,e){let{n}=e;return g.length===n?g:f.error("function.arity",{n})}},class:{method(){return this.$_addRule("class")},validate:(g,f)=>/^\s*class\s/.test(g.toString())?g:f.error("function.class",{value:g})},minArity:{method(g){return o(Number.isSafeInteger(g)&&g>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:g}})},validate(g,f,e){let{n}=e;return g.length>=n?g:f.error("function.minArity",{n})}},maxArity:{method(g){return o(Number.isSafeInteger(g)&&g>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:g}})},validate(g,f,e){let{n}=e;return g.length<=n?g:f.error("function.maxArity",{n})}}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(S,w,b)=>{const o=b(978),v=b(375),g=b(8571),f=b(3652),e=b(8068),n=b(8160),a=b(3292),s=b(6354),t=b(6133),l=b(3328),r={renameDefaults:{alias:!1,multiple:!1,override:!1}};S.exports=e.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(i,c)=>i.keys(c),validate(i,c){let{schema:d,error:y,state:x,prefs:_}=c;if(!i||typeof i!==d.$_property("typeof")||Array.isArray(i))return{value:i,errors:y("object.base",{type:d.$_property("typeof")})};if(!(d.$_terms.renames||d.$_terms.dependencies||d.$_terms.keys||d.$_terms.patterns||d.$_terms.externals))return;i=r.clone(i,_);const u=[];if(d.$_terms.renames&&!r.rename(d,i,x,_,u))return{value:i,errors:u};if(!d.$_terms.keys&&!d.$_terms.patterns&&!d.$_terms.dependencies)return{value:i,errors:u};const m=new Set(Object.keys(i));if(d.$_terms.keys){const h=[i,...x.ancestors];for(const $ of d.$_terms.keys){const j=$.key,E=i[j];m.delete(j);const N=x.localize([...x.path,j],h,$),M=$.schema.$_validate(E,N,_);if(M.errors){if(_.abortEarly)return{value:i,errors:M.errors};M.value!==void 0&&(i[j]=M.value),u.push(...M.errors)}else $.schema._flags.result==="strip"||M.value===void 0&&E!==void 0?delete i[j]:M.value!==void 0&&(i[j]=M.value)}}if(m.size||d._flags._hasPatternMatch){const h=r.unknown(d,i,m,u,x,_);if(h)return h}if(d.$_terms.dependencies)for(const h of d.$_terms.dependencies){if(h.key!==null&&r.isPresent(h.options)(h.key.resolve(i,x,_,null,{shadow:!1}))===!1)continue;const $=r.dependencies[h.rel](d,h,i,x,_);if($){const j=d.$_createError($.code,i,$.context,x,_);if(_.abortEarly)return{value:i,errors:j};u.push(j)}}return{value:i,errors:u}},rules:{and:{method(){for(var i=arguments.length,c=new Array(i),d=0;d<i;d++)c[d]=arguments[d];return n.verifyFlat(c,"and"),r.dependency(this,"and",null,c)}},append:{method(i){return i==null||Object.keys(i).length===0?this:this.keys(i)}},assert:{method(i,c,d){l.isTemplate(i)||(i=a.ref(i)),v(d===void 0||typeof d=="string","Message must be a string"),c=this.$_compile(c,{appendPath:!0});const y=this.$_addRule({name:"assert",args:{subject:i,schema:c,message:d}});return y.$_mutateRegister(i),y.$_mutateRegister(c),y},validate(i,c,d){let{error:y,prefs:x,state:_}=c,{subject:u,schema:m,message:h}=d;const $=u.resolve(i,_,x),j=t.isRef(u)?u.absolute(_):[];return m.$_match($,_.localize(j,[i,..._.ancestors],m),x)?i:y("object.assert",{subject:u,message:h})},args:["subject","schema","message"],multi:!0},instance:{method(i,c){return v(typeof i=="function","constructor must be a function"),c=c||i.name,this.$_addRule({name:"instance",args:{constructor:i,name:c}})},validate(i,c,d){let{constructor:y,name:x}=d;return i instanceof y?i:c.error("object.instance",{type:x,value:i})},args:["constructor","name"]},keys:{method(i){v(i===void 0||typeof i=="object","Object schema must be a valid object"),v(!n.isSchema(i),"Object schema cannot be a joi schema");const c=this.clone();if(i)if(Object.keys(i).length){c.$_terms.keys=c.$_terms.keys?c.$_terms.keys.filter(d=>!i.hasOwnProperty(d.key)):new r.Keys;for(const d in i)n.tryWithPath(()=>c.$_terms.keys.push({key:d,schema:this.$_compile(i[d])}),d)}else c.$_terms.keys=new r.Keys;else c.$_terms.keys=null;return c.$_mutateRebuild()}},length:{method(i){return this.$_addRule({name:"length",args:{limit:i},operator:"="})},validate(i,c,d,y){let{limit:x}=d,{name:_,operator:u,args:m}=y;return n.compare(Object.keys(i).length,x,u)?i:c.error("object."+_,{limit:m.limit,value:i})},args:[{name:"limit",ref:!0,assert:n.limit,message:"must be a positive integer"}]},max:{method(i){return this.$_addRule({name:"max",method:"length",args:{limit:i},operator:"<="})}},min:{method(i){return this.$_addRule({name:"min",method:"length",args:{limit:i},operator:">="})}},nand:{method(){for(var i=arguments.length,c=new Array(i),d=0;d<i;d++)c[d]=arguments[d];return n.verifyFlat(c,"nand"),r.dependency(this,"nand",null,c)}},or:{method(){for(var i=arguments.length,c=new Array(i),d=0;d<i;d++)c[d]=arguments[d];return n.verifyFlat(c,"or"),r.dependency(this,"or",null,c)}},oxor:{method(){for(var i=arguments.length,c=new Array(i),d=0;d<i;d++)c[d]=arguments[d];return r.dependency(this,"oxor",null,c)}},pattern:{method(i,c){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const y=i instanceof RegExp;y||(i=this.$_compile(i,{appendPath:!0})),v(c!==void 0,"Invalid rule"),n.assertOptions(d,["fallthrough","matches"]),y&&v(!i.flags.includes("g")&&!i.flags.includes("y"),"pattern should not use global or sticky mode"),c=this.$_compile(c,{appendPath:!0});const x=this.clone();x.$_terms.patterns=x.$_terms.patterns||[];const _={[y?"regex":"schema"]:i,rule:c};return d.matches&&(_.matches=this.$_compile(d.matches),_.matches.type!=="array"&&(_.matches=_.matches.$_root.array().items(_.matches)),x.$_mutateRegister(_.matches),x.$_setFlag("_hasPatternMatch",!0,{clone:!1})),d.fallthrough&&(_.fallthrough=!0),x.$_terms.patterns.push(_),x.$_mutateRegister(c),x}},ref:{method(){return this.$_addRule("ref")},validate:(i,c)=>t.isRef(i)?i:c.error("object.refType",{value:i})},regex:{method(){return this.$_addRule("regex")},validate:(i,c)=>i instanceof RegExp?i:c.error("object.regex",{value:i})},rename:{method(i,c){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};v(typeof i=="string"||i instanceof RegExp,"Rename missing the from argument"),v(typeof c=="string"||c instanceof l,"Invalid rename to argument"),v(c!==i,"Cannot rename key to same name:",i),n.assertOptions(d,["alias","ignoreUndefined","override","multiple"]);const y=this.clone();y.$_terms.renames=y.$_terms.renames||[];for(const x of y.$_terms.renames)v(x.from!==i,"Cannot rename the same key multiple times");return c instanceof l&&y.$_mutateRegister(c),y.$_terms.renames.push({from:i,to:c,options:o(r.renameDefaults,d)}),y}},schema:{method(){let i=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"any";return this.$_addRule({name:"schema",args:{type:i}})},validate(i,c,d){let{type:y}=d;return!n.isSchema(i)||y!=="any"&&i.type!==y?c.error("object.schema",{type:y}):i}},unknown:{method(i){return this.$_setFlag("unknown",i!==!1)}},with:{method(i,c){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return r.dependency(this,"with",i,c,d)}},without:{method(i,c){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return r.dependency(this,"without",i,c,d)}},xor:{method(){for(var i=arguments.length,c=new Array(i),d=0;d<i;d++)c[d]=arguments[d];return n.verifyFlat(c,"xor"),r.dependency(this,"xor",null,c)}}},overrides:{default(i,c){return i===void 0&&(i=n.symbols.deepDefault),this.$_parent("default",i,c)}},rebuild(i){if(i.$_terms.keys){const c=new f.Sorter;for(const d of i.$_terms.keys)n.tryWithPath(()=>c.add(d,{after:d.schema.$_rootReferences(),group:d.key}),d.key);i.$_terms.keys=new r.Keys(...c.nodes)}},manifest:{build(i,c){if(c.keys&&(i=i.keys(c.keys)),c.dependencies)for(const{rel:d,key:y=null,peers:x,options:_}of c.dependencies)i=r.dependency(i,d,y,x,_);if(c.patterns)for(const{regex:d,schema:y,rule:x,fallthrough:_,matches:u}of c.patterns)i=i.pattern(d||y,x,{fallthrough:_,matches:u});if(c.renames)for(const{from:d,to:y,options:x}of c.renames)i=i.rename(d,y,x);return i}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),r.clone=function(i,c){if(typeof i=="object"){if(c.nonEnumerables)return g(i,{shallow:!0});const y=Object.create(Object.getPrototypeOf(i));return Object.assign(y,i),y}const d=D(function(){for(var y=arguments.length,x=new Array(y),_=0;_<y;_++)x[_]=arguments[_];return i.apply(this,x)},"r");return d.prototype=g(i.prototype),Object.defineProperty(d,"name",{value:i.name,writable:!1}),Object.defineProperty(d,"length",{value:i.length,writable:!1}),Object.assign(d,i),d},r.dependency=function(i,c,d,y,x){v(d===null||typeof d=="string",c,"key must be a strings"),x||(x=y.length>1&&typeof y[y.length-1]=="object"?y.pop():{}),n.assertOptions(x,["separator","isPresent"]),y=[].concat(y);const _=n.default(x.separator,"."),u=[];for(const h of y)v(typeof h=="string",c,"peers must be strings"),u.push(a.ref(h,{separator:_,ancestor:0,prefix:!1}));d!==null&&(d=a.ref(d,{separator:_,ancestor:0,prefix:!1}));const m=i.clone();return m.$_terms.dependencies=m.$_terms.dependencies||[],m.$_terms.dependencies.push(new r.Dependency(c,d,u,y,x)),m},r.dependencies={and(i,c,d,y,x){const _=[],u=[],m=c.peers.length,h=r.isPresent(c.options);for(const $ of c.peers)h($.resolve(d,y,x,null,{shadow:!1}))===!1?_.push($.key):u.push($.key);if(_.length!==m&&u.length!==m)return{code:"object.and",context:{present:u,presentWithLabels:r.keysToLabels(i,u),missing:_,missingWithLabels:r.keysToLabels(i,_)}}},nand(i,c,d,y,x){const _=[],u=r.isPresent(c.options);for(const $ of c.peers)u($.resolve(d,y,x,null,{shadow:!1}))&&_.push($.key);if(_.length!==c.peers.length)return;const m=c.paths[0],h=c.paths.slice(1);return{code:"object.nand",context:{main:m,mainWithLabel:r.keysToLabels(i,m),peers:h,peersWithLabels:r.keysToLabels(i,h)}}},or(i,c,d,y,x){const _=r.isPresent(c.options);for(const u of c.peers)if(_(u.resolve(d,y,x,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:c.paths,peersWithLabels:r.keysToLabels(i,c.paths)}}},oxor(i,c,d,y,x){const _=[],u=r.isPresent(c.options);for(const h of c.peers)u(h.resolve(d,y,x,null,{shadow:!1}))&&_.push(h.key);if(!_.length||_.length===1)return;const m={peers:c.paths,peersWithLabels:r.keysToLabels(i,c.paths)};return m.present=_,m.presentWithLabels=r.keysToLabels(i,_),{code:"object.oxor",context:m}},with(i,c,d,y,x){const _=r.isPresent(c.options);for(const u of c.peers)if(_(u.resolve(d,y,x,null,{shadow:!1}))===!1)return{code:"object.with",context:{main:c.key.key,mainWithLabel:r.keysToLabels(i,c.key.key),peer:u.key,peerWithLabel:r.keysToLabels(i,u.key)}}},without(i,c,d,y,x){const _=r.isPresent(c.options);for(const u of c.peers)if(_(u.resolve(d,y,x,null,{shadow:!1})))return{code:"object.without",context:{main:c.key.key,mainWithLabel:r.keysToLabels(i,c.key.key),peer:u.key,peerWithLabel:r.keysToLabels(i,u.key)}}},xor(i,c,d,y,x){const _=[],u=r.isPresent(c.options);for(const h of c.peers)u(h.resolve(d,y,x,null,{shadow:!1}))&&_.push(h.key);if(_.length===1)return;const m={peers:c.paths,peersWithLabels:r.keysToLabels(i,c.paths)};return _.length===0?{code:"object.missing",context:m}:(m.present=_,m.presentWithLabels=r.keysToLabels(i,_),{code:"object.xor",context:m})}},r.keysToLabels=function(i,c){return Array.isArray(c)?c.map(d=>i.$_mapLabels(d)):i.$_mapLabels(c)},r.isPresent=function(i){return typeof i.isPresent=="function"?i.isPresent:c=>c!==void 0},r.rename=function(i,c,d,y,x){const _={};for(const u of i.$_terms.renames){const m=[],h=typeof u.from!="string";if(h)for(const $ in c){if(c[$]===void 0&&u.options.ignoreUndefined||$===u.to)continue;const j=u.from.exec($);j&&m.push({from:$,to:u.to,match:j})}else!Object.prototype.hasOwnProperty.call(c,u.from)||c[u.from]===void 0&&u.options.ignoreUndefined||m.push(u);for(const $ of m){const j=$.from;let E=$.to;if(E instanceof l&&(E=E.render(c,d,y,$.match)),j!==E){if(!u.options.multiple&&_[E]&&(x.push(i.$_createError("object.rename.multiple",c,{from:j,to:E,pattern:h},d,y)),y.abortEarly)||Object.prototype.hasOwnProperty.call(c,E)&&!u.options.override&&!_[E]&&(x.push(i.$_createError("object.rename.override",c,{from:j,to:E,pattern:h},d,y)),y.abortEarly))return!1;c[j]===void 0?delete c[E]:c[E]=c[j],_[E]=!0,u.options.alias||delete c[j]}}}return!0},r.unknown=function(i,c,d,y,x,_){if(i.$_terms.patterns){let u=!1;const m=i.$_terms.patterns.map($=>{if($.matches)return u=!0,[]}),h=[c,...x.ancestors];for(const $ of d){const j=c[$],E=[...x.path,$];for(let N=0;N<i.$_terms.patterns.length;++N){const M=i.$_terms.patterns[N];if(M.regex){const K=M.regex.test($);if(x.mainstay.tracer.debug(x,"rule",`pattern.${N}`,K?"pass":"error"),!K)continue}else if(!M.schema.$_match($,x.nest(M.schema,`pattern.${N}`),_))continue;d.delete($);const V=x.localize(E,h,{schema:M.rule,key:$}),W=M.rule.$_validate(j,V,_);if(W.errors){if(_.abortEarly)return{value:c,errors:W.errors};y.push(...W.errors)}if(M.matches&&m[N].push($),c[$]=W.value,!M.fallthrough)break}}if(u)for(let $=0;$<m.length;++$){const j=m[$];if(!j)continue;const E=i.$_terms.patterns[$].matches,N=x.localize(x.path,h,E),M=E.$_validate(j,N,_);if(M.errors){const V=s.details(M.errors,{override:!1});V.matches=j;const W=i.$_createError("object.pattern.match",c,V,x,_);if(_.abortEarly)return{value:c,errors:W};y.push(W)}}}if(d.size&&(i.$_terms.keys||i.$_terms.patterns)){if(_.stripUnknown&&!i._flags.unknown||_.skipFunctions){const u=!(!_.stripUnknown||_.stripUnknown!==!0&&!_.stripUnknown.objects);for(const m of d)u?(delete c[m],d.delete(m)):typeof c[m]=="function"&&d.delete(m)}if(!n.default(i._flags.unknown,_.allowUnknown))for(const u of d){const m=x.localize([...x.path,u],[]),h=i.$_createError("object.unknown",c[u],{child:u},m,_,{flags:!1});if(_.abortEarly)return{value:c,errors:h};y.push(h)}}},r.Dependency=class{constructor(i,c,d,y,x){this.rel=i,this.key=c,this.peers=d,this.paths=y,this.options=x}describe(){const i={rel:this.rel,peers:this.paths};return this.key!==null&&(i.key=this.key.key),this.peers[0].separator!=="."&&(i.options={...i.options,separator:this.peers[0].separator}),this.options.isPresent&&(i.options={...i.options,isPresent:this.options.isPresent}),i}},r.Keys=class extends Array{concat(i){const c=this.slice(),d=new Map;for(let y=0;y<c.length;++y)d.set(c[y].key,y);for(const y of i){const x=y.key,_=d.get(x);_!==void 0?c[_]={key:x,schema:c[_].schema.concat(y.schema)}:c.push(y)}return c}}},8785:(S,w,b)=>{const o=b(375),v=b(8068),g=b(8160),f=b(3292),e=b(6354),n={};S.exports=v.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(a,s)=>a.ref(s),validate(a,s){let{schema:t,state:l,prefs:r}=s;o(t.$_terms.link,"Uninitialized link schema");const i=n.generate(t,a,l,r),c=t.$_terms.link[0].ref;return i.$_validate(a,l.nest(i,`link:${c.display}:${i.type}`),r)},generate:(a,s,t,l)=>n.generate(a,s,t,l),rules:{ref:{method(a){o(!this.$_terms.link,"Cannot reinitialize schema"),a=f.ref(a),o(a.type==="value"||a.type==="local","Invalid reference type:",a.type),o(a.type==="local"||a.ancestor==="root"||a.ancestor>0,"Link cannot reference itself");const s=this.clone();return s.$_terms.link=[{ref:a}],s}},relative:{method(){let a=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return this.$_setFlag("relative",a)}}},overrides:{concat(a){o(this.$_terms.link,"Uninitialized link schema"),o(g.isSchema(a),"Invalid schema object"),o(a.type!=="link","Cannot merge type link with another link");const s=this.clone();return s.$_terms.whens||(s.$_terms.whens=[]),s.$_terms.whens.push({concat:a}),s.$_mutateRebuild()}},manifest:{build:(a,s)=>(o(s.link,"Invalid link description missing link"),a.ref(s.link))}}),n.generate=function(a,s,t,l){let r=t.mainstay.links.get(a);if(r)return r._generate(s,t,l).schema;const i=a.$_terms.link[0].ref,{perspective:c,path:d}=n.perspective(i,t);n.assert(c,"which is outside of schema boundaries",i,a,t,l);try{r=d.length?c.$_reach(d):c}catch{n.assert(!1,"to non-existing schema",i,a,t,l)}return n.assert(r.type!=="link","which is another link",i,a,t,l),a._flags.relative||t.mainstay.links.set(a,r),r._generate(s,t,l).schema},n.perspective=function(a,s){if(a.type==="local"){for(const{schema:t,key:l}of s.schemas){if((t._flags.id||l)===a.path[0])return{perspective:t,path:a.path.slice(1)};if(t.$_terms.shared){for(const r of t.$_terms.shared)if(r._flags.id===a.path[0])return{perspective:r,path:a.path.slice(1)}}}return{perspective:null,path:null}}return a.ancestor==="root"?{perspective:s.schemas[s.schemas.length-1].schema,path:a.path}:{perspective:s.schemas[a.ancestor]&&s.schemas[a.ancestor].schema,path:a.path}},n.assert=function(a,s,t,l,r,i){a||o(!1,`"${e.label(l._flags,r,i)}" contains link reference "${t.display}" ${s}`)}},3832:(S,w,b)=>{const o=b(375),v=b(8068),g=b(8160),f={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/};S.exports=v.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(e,n){let{schema:a,error:s}=n;if(!e.match(f.numberRx))return;e=e.trim();const t={value:parseFloat(e)};if(t.value===0&&(t.value=0),!a._flags.unsafe)if(e.match(/e/i)){if(f.extractSignificantDigits(e)!==f.extractSignificantDigits(String(t.value)))return t.errors=s("number.unsafe"),t}else{const l=t.value.toString();if(l.match(/e/i))return t;if(l!==f.normalizeDecimal(e))return t.errors=s("number.unsafe"),t}return t}},validate(e,n){let{schema:a,error:s,prefs:t}=n;if(e===1/0||e===-1/0)return{value:e,errors:s("number.infinity")};if(!g.isNumber(e))return{value:e,errors:s("number.base")};const l={value:e};if(t.convert){const r=a.$_getRule("precision");if(r){const i=Math.pow(10,r.args.limit);l.value=Math.round(l.value*i)/i}}return l.value===0&&(l.value=0),!a._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(l.errors=s("number.unsafe")),l},rules:{compare:{method:!1,validate(e,n,a,s){let{limit:t}=a,{name:l,operator:r,args:i}=s;return g.compare(e,t,r)?e:n.error("number."+l,{limit:i.limit,value:e})},args:[{name:"limit",ref:!0,assert:g.isNumber,message:"must be a number"}]},greater:{method(e){return this.$_addRule({name:"greater",method:"compare",args:{limit:e},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(e,n)=>Math.trunc(e)-e==0?e:n.error("number.integer")},less:{method(e){return this.$_addRule({name:"less",method:"compare",args:{limit:e},operator:"<"})}},max:{method(e){return this.$_addRule({name:"max",method:"compare",args:{limit:e},operator:"<="})}},min:{method(e){return this.$_addRule({name:"min",method:"compare",args:{limit:e},operator:">="})}},multiple:{method(e){return this.$_addRule({name:"multiple",args:{base:e}})},validate(e,n,a,s){let{base:t}=a;return e*(1/t)%1==0?e:n.error("number.multiple",{multiple:s.args.base,value:e})},args:[{name:"base",ref:!0,assert:e=>typeof e=="number"&&isFinite(e)&&e>0,message:"must be a positive number"}],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(e,n)=>Number.isSafeInteger(e)&&e>=0&&e<=65535?e:n.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(e){return o(Number.isSafeInteger(e),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:e}})},validate(e,n,a){let{limit:s}=a;const t=e.toString().match(f.precisionRx);return Math.max((t[1]?t[1].length:0)-(t[2]?parseInt(t[2],10):0),0)<=s?e:n.error("number.precision",{limit:s,value:e})},convert:!0},sign:{method(e){return o(["negative","positive"].includes(e),"Invalid sign",e),this.$_addRule({name:"sign",args:{sign:e}})},validate(e,n,a){let{sign:s}=a;return s==="negative"&&e<0||s==="positive"&&e>0?e:n.error(`number.${s}`)}},unsafe:{method(){let e=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return o(typeof e=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",e)}}},cast:{string:{from:e=>typeof e=="number",to:(e,n)=>e.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),f.extractSignificantDigits=function(e){return e.replace(f.exponentialPartRegex,"").replace(f.dotRegex,"").replace(f.trailingZerosRegex,"").replace(f.leadingSignAndZerosRegex,"")},f.normalizeDecimal=function(e){return(e=e.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&e.endsWith("0")&&(e=e.replace(/0+$/,"")),e==="-0"?"0":e}},8966:(S,w,b)=>{const o=b(7824);S.exports=o.extend({type:"object",cast:{map:{from:v=>v&&typeof v=="object",to:(v,g)=>new Map(Object.entries(v))}}})},7417:(S,w,b)=>{const o=b(375),v=b(5380),g=b(1745),f=b(9959),e=b(6064),n=b(9926),a=b(5752),s=b(8068),t=b(8160),l={tlds:n instanceof Set&&{tlds:{allow:n,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:/^[a-f0-9]+$/i,ipRegex:f.regex({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};S.exports=s.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(r,i){let{schema:c,state:d,prefs:y}=i;const x=c.$_getRule("normalize");x&&(r=r.normalize(x.args.form));const _=c.$_getRule("case");_&&(r=_.args.direction==="upper"?r.toLocaleUpperCase():r.toLocaleLowerCase());const u=c.$_getRule("trim");if(u&&u.args.enabled&&(r=r.trim()),c.$_terms.replacements)for(const h of c.$_terms.replacements)r=r.replace(h.pattern,h.replacement);const m=c.$_getRule("hex");if(m&&m.args.options.byteAligned&&r.length%2!=0&&(r=`0${r}`),c.$_getRule("isoDate")){const h=l.isoDate(r);h&&(r=h)}if(c._flags.truncate){const h=c.$_getRule("max");if(h){let $=h.args.limit;if(t.isResolvable($)&&($=$.resolve(r,d,y),!t.limit($)))return{value:r,errors:c.$_createError("any.ref",$,{ref:h.args.limit,arg:"limit",reason:"must be a positive integer"},d,y)};r=r.slice(0,$)}}return{value:r}}},validate(r,i){let{schema:c,error:d}=i;if(typeof r!="string")return{value:r,errors:d("string.base")};if(r===""){const y=c.$_getRule("min");return y&&y.args.limit===0?void 0:{value:r,errors:d("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(r,i)=>/^[a-zA-Z0-9]+$/.test(r)?r:i.error("string.alphanum")},base64:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return t.assertOptions(r,["paddingRequired","urlSafe"]),r={urlSafe:!1,paddingRequired:!0,...r},o(typeof r.paddingRequired=="boolean","paddingRequired must be boolean"),o(typeof r.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:r}})},validate(r,i,c){let{options:d}=c;return l.base64Regex[d.paddingRequired][d.urlSafe].test(r)?r:i.error("string.base64")}},case:{method(r){return o(["lower","upper"].includes(r),"Invalid case:",r),this.$_addRule({name:"case",args:{direction:r}})},validate(r,i,c){let{direction:d}=c;return d==="lower"&&r===r.toLocaleLowerCase()||d==="upper"&&r===r.toLocaleUpperCase()?r:i.error(`string.${d}case`)},convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(r,i){let c=r.length,d=0,y=1;for(;c--;){const x=r.charAt(c)*y;d+=x-9*(x>9),y^=3}return d>0&&d%10==0?r:i.error("string.creditCard")}},dataUri:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return t.assertOptions(r,["paddingRequired"]),r={paddingRequired:!0,...r},o(typeof r.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:r}})},validate(r,i,c){let{options:d}=c;const y=r.match(l.dataUriRegex);return y&&(!y[2]||y[2]!=="base64"||l.base64Regex[d.paddingRequired].false.test(y[3]))?r:i.error("string.dataUri")}},domain:{method(r){r&&t.assertOptions(r,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const i=l.addressOptions(r);return this.$_addRule({name:"domain",args:{options:r},address:i})},validate(r,i,c,d){let{address:y}=d;return v.isValid(r,y)?r:i.error("string.domain")}},email:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.assertOptions(r,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),o(r.multiple===void 0||typeof r.multiple=="boolean","multiple option must be an boolean");const i=l.addressOptions(r),c=new RegExp(`\\s*[${r.separator?e(r.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:r},regex:c,address:i})},validate(r,i,c,d){let{options:y}=c,{regex:x,address:_}=d;const u=y.multiple?r.split(x):[r],m=[];for(const h of u)g.isValid(h,_)||m.push(h);return m.length?i.error("string.email",{value:r,invalids:m}):r}},guid:{alias:"uuid",method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.assertOptions(r,["version","separator"]);let i="";if(r.version){const y=[].concat(r.version);o(y.length>=1,"version must have at least 1 valid version specified");const x=new Set;for(let _=0;_<y.length;++_){const u=y[_];o(typeof u=="string","version at position "+_+" must be a string");const m=l.guidVersions[u.toLowerCase()];o(m,"version at position "+_+" must be one of "+Object.keys(l.guidVersions).join(", ")),o(!x.has(m),"version at position "+_+" must not be a duplicate"),i+=m,x.add(m)}}o(l.guidSeparators.has(r.separator),'separator must be one of true, false, "-", or ":"');const c=r.separator===void 0?"[:-]?":r.separator===!0?"[:-]":r.separator===!1?"[]?":`\\${r.separator}`,d=new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${c})[0-9A-F]{4}\\2?[${i||"0-9A-F"}][0-9A-F]{3}\\2?[${i?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");return this.$_addRule({name:"guid",args:{options:r},regex:d})},validate(r,i,c,d){let{regex:y}=d;const x=y.exec(r);return x?l.guidBrackets[x[1]]!==x[x.length-1]?i.error("string.guid"):r:i.error("string.guid")}},hex:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return t.assertOptions(r,["byteAligned"]),r={byteAligned:!1,...r},o(typeof r.byteAligned=="boolean","byteAligned must be boolean"),this.$_addRule({name:"hex",args:{options:r}})},validate(r,i,c){let{options:d}=c;return l.hexRegex.test(r)?d.byteAligned&&r.length%2!=0?i.error("string.hexAlign"):r:i.error("string.hex")}},hostname:{method(){return this.$_addRule("hostname")},validate:(r,i)=>v.isValid(r,{minDomainSegments:1})||l.ipRegex.test(r)?r:i.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.assertOptions(r,["cidr","version"]);const{cidr:i,versions:c,regex:d}=f.regex(r),y=r.version?c:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:i,version:y}},regex:d})},validate(r,i,c,d){let{options:y}=c,{regex:x}=d;return x.test(r)?r:y.version?i.error("string.ipVersion",{value:r,cidr:y.cidr,version:y.version}):i.error("string.ip",{value:r,cidr:y.cidr})}},isoDate:{method(){return this.$_addRule("isoDate")},validate(r,i){let{error:c}=i;return l.isoDate(r)?r:c("string.isoDate")}},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(r,i)=>l.isoDurationRegex.test(r)?r:i.error("string.isoDuration")},length:{method(r,i){return l.length(this,"length",r,"=",i)},validate(r,i,c,d){let{limit:y,encoding:x}=c,{name:_,operator:u,args:m}=d;const h=!x&&r.length;return t.compare(h,y,u)?r:i.error("string."+_,{limit:m.limit,value:r,encoding:x})},args:[{name:"limit",ref:!0,assert:t.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(r,i){return l.length(this,"max",r,"<=",i)},args:["limit","encoding"]},min:{method(r,i){return l.length(this,"min",r,">=",i)},args:["limit","encoding"]},normalize:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"NFC";return o(l.normalizationForms.includes(r),"normalization form must be one of "+l.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:r}})},validate(r,i,c){let{error:d}=i,{form:y}=c;return r===r.normalize(y)?r:d("string.normalize",{value:r,form:y})},convert:!0},pattern:{alias:"regex",method(r){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};o(r instanceof RegExp,"regex must be a RegExp"),o(!r.flags.includes("g")&&!r.flags.includes("y"),"regex should not use global or sticky mode"),typeof i=="string"&&(i={name:i}),t.assertOptions(i,["invert","name"]);const c=["string.pattern",i.invert?".invert":"",i.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:r,options:i},errorCode:c})},validate(r,i,c,d){let{regex:y,options:x}=c,{errorCode:_}=d;return y.test(r)^x.invert?r:i.error(_,{name:x.name,regex:y,value:r})},args:["regex","options"],multi:!0},replace:{method(r,i){typeof r=="string"&&(r=new RegExp(e(r),"g")),o(r instanceof RegExp,"pattern must be a RegExp"),o(typeof i=="string","replacement must be a String");const c=this.clone();return c.$_terms.replacements||(c.$_terms.replacements=[]),c.$_terms.replacements.push({pattern:r,replacement:i}),c}},token:{method(){return this.$_addRule("token")},validate:(r,i)=>/^\w+$/.test(r)?r:i.error("string.token")},trim:{method(){let r=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return o(typeof r=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:r}})},validate(r,i,c){let{enabled:d}=c;return d&&r!==r.trim()?i.error("string.trim"):r},convert:!0},truncate:{method(){let r=!(arguments.length>0&&arguments[0]!==void 0)||arguments[0];return o(typeof r=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",r)}},uppercase:{method(){return this.case("upper")}},uri:{method(){let r=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.assertOptions(r,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme"]),r.domain&&t.assertOptions(r.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:i,scheme:c}=a.regex(r),d=r.domain?l.addressOptions(r.domain):null;return this.$_addRule({name:"uri",args:{options:r},regex:i,domain:d,scheme:c})},validate(r,i,c,d){let{options:y}=c,{regex:x,domain:_,scheme:u}=d;if(["http:/","https:/"].includes(r))return i.error("string.uri");const m=x.exec(r);if(m){const h=m[1]||m[2];return!_||y.allowRelative&&!h||v.isValid(h,_)?r:i.error("string.domain",{value:h})}return y.relativeOnly?i.error("string.uriRelativeOnly"):y.scheme?i.error("string.uriCustomScheme",{scheme:u,value:r}):i.error("string.uri")}}},manifest:{build(r,i){if(i.replacements)for(const{pattern:c,replacement:d}of i.replacements)r=r.replace(c,d);return r}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),l.addressOptions=function(r){if(!r||(o(r.minDomainSegments===void 0||Number.isSafeInteger(r.minDomainSegments)&&r.minDomainSegments>0,"minDomainSegments must be a positive integer"),o(r.maxDomainSegments===void 0||Number.isSafeInteger(r.maxDomainSegments)&&r.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),r.tlds===!1))return r;if(r.tlds===!0||r.tlds===void 0)return o(l.tlds,"Built-in TLD list disabled"),Object.assign({},r,l.tlds);o(typeof r.tlds=="object","tlds must be true, false, or an object");const i=r.tlds.deny;if(i)return Array.isArray(i)&&(r=Object.assign({},r,{tlds:{deny:new Set(i)}})),o(r.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),o(!r.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),l.validateTlds(r.tlds.deny,"tlds.deny"),r;const c=r.tlds.allow;return c?c===!0?(o(l.tlds,"Built-in TLD list disabled"),Object.assign({},r,l.tlds)):(Array.isArray(c)&&(r=Object.assign({},r,{tlds:{allow:new Set(c)}})),o(r.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),l.validateTlds(r.tlds.allow,"tlds.allow"),r):r},l.validateTlds=function(r,i){for(const c of r)o(v.isValid(c,{minDomainSegments:1,maxDomainSegments:1}),`${i} must contain valid top level domain names`)},l.isoDate=function(r){if(!t.isIsoDate(r))return null;/.*T.*[+-]\d\d$/.test(r)&&(r+="00");const i=new Date(r);return isNaN(i.getTime())?null:i.toISOString()},l.length=function(r,i,c,d,y){return o(!y||!1,"Invalid encoding:",y),r.$_addRule({name:i,method:"length",args:{limit:c,encoding:y},operator:d})}},8826:(S,w,b)=>{const o=b(375),v=b(8068),g={};g.Map=class extends Map{slice(){return new g.Map(this)}},S.exports=v.extend({type:"symbol",terms:{map:{init:new g.Map}},coerce:{method(f,e){let{schema:n,error:a}=e;const s=n.$_terms.map.get(f);return s&&(f=s),n._flags.only&&typeof f!="symbol"?{value:f,errors:a("symbol.map",{map:n.$_terms.map})}:{value:f}}},validate(f,e){let{error:n}=e;if(typeof f!="symbol")return{value:f,errors:n("symbol.base")}},rules:{map:{method(f){f&&!f[Symbol.iterator]&&typeof f=="object"&&(f=Object.entries(f)),o(f&&f[Symbol.iterator],"Iterable must be an iterable or object");const e=this.clone(),n=[];for(const a of f){o(a&&a[Symbol.iterator],"Entry must be an iterable");const[s,t]=a;o(typeof s!="object"&&typeof s!="function"&&typeof s!="symbol","Key must not be of type object, function, or Symbol"),o(typeof t=="symbol","Value must be a Symbol"),e.$_terms.map.set(s,t),n.push(t)}return e.valid(...n)}}},manifest:{build:(f,e)=>(e.map&&(f=f.map(e.map)),f)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(S,w,b)=>{const o=b(375),v=b(8571),g=b(738),f=b(9621),e=b(8160),n=b(6354),a=b(493),s={result:Symbol("result")};w.entry=function(t,l,r){let i=e.defaults;r&&(o(r.warnings===void 0,"Cannot override warnings preference in synchronous validation"),o(r.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),i=e.preferences(e.defaults,r));const c=s.entry(t,l,i);o(!c.mainstay.externals.length,"Schema with external rules must use validateAsync()");const d={value:c.value};return c.error&&(d.error=c.error),c.mainstay.warnings.length&&(d.warning=n.details(c.mainstay.warnings)),c.mainstay.debug&&(d.debug=c.mainstay.debug),c.mainstay.artifacts&&(d.artifacts=c.mainstay.artifacts),d},w.entryAsync=async function(t,l,r){let i=e.defaults;r&&(i=e.preferences(e.defaults,r));const c=s.entry(t,l,i),d=c.mainstay;if(c.error)throw d.debug&&(c.error.debug=d.debug),c.error;if(d.externals.length){let x=c.value;for(const{method:_,path:u,label:m}of d.externals){let h,$,j=x;u.length&&(h=u[u.length-1],$=f(x,u.slice(0,-1)),j=$[h]);try{const E=await _(j,{prefs:r});if(E===void 0||E===j)continue;$?$[h]=E:x=E}catch(E){throw i.errors.label&&(E.message+=` (${m})`),E}}c.value=x}if(!i.warnings&&!i.debug&&!i.artifacts)return c.value;const y={value:c.value};return d.warnings.length&&(y.warning=n.details(d.warnings)),d.debug&&(y.debug=d.debug),d.artifacts&&(y.artifacts=d.artifacts),y},s.entry=function(t,l,r){const{tracer:i,cleanup:c}=s.tracer(l,r),d={externals:[],warnings:[],tracer:i,debug:r.debug?[]:null,links:l._ids._schemaChain?new Map:null},y=l._ids._schemaChain?[{schema:l}]:null,x=new a([],[],{mainstay:d,schemas:y}),_=w.validate(t,l,x,r);c&&l.$_root.untrace();const u=n.process(_.errors,t,r);return{value:_.value,error:u,mainstay:d}},s.tracer=function(t,l){return t.$_root._tracer?{tracer:t.$_root._tracer._register(t)}:l.debug?(o(t.$_root.trace,"Debug mode not supported"),{tracer:t.$_root.trace()._register(t),cleanup:!0}):{tracer:s.ignore}},w.validate=function(t,l,r,i){let c=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{};if(l.$_terms.whens&&(l=l._generate(t,r,i).schema),l._preferences&&(i=s.prefs(l,i)),l._cache&&i.cache){const h=l._cache.get(t);if(r.mainstay.tracer.debug(r,"validate","cached",!!h),h)return h}const d=D((h,$,j)=>l.$_createError(h,t,$,j||r,i),"a"),y={original:t,prefs:i,schema:l,state:r,error:d,errorsArray:s.errorsArray,warn:(h,$,j)=>r.mainstay.warnings.push(d(h,$,j)),message:(h,$)=>l.$_createError("custom",t,$,r,i,{messages:h})};r.mainstay.tracer.entry(l,r);const x=l._definition;if(x.prepare&&t!==void 0&&i.convert){const h=x.prepare(t,y);if(h){if(r.mainstay.tracer.value(r,"prepare",t,h.value),h.errors)return s.finalize(h.value,[].concat(h.errors),y);t=h.value}}if(x.coerce&&t!==void 0&&i.convert&&(!x.coerce.from||x.coerce.from.includes(typeof t))){const h=x.coerce.method(t,y);if(h){if(r.mainstay.tracer.value(r,"coerced",t,h.value),h.errors)return s.finalize(h.value,[].concat(h.errors),y);t=h.value}}const _=l._flags.empty;_&&_.$_match(s.trim(t,l),r.nest(_),e.defaults)&&(r.mainstay.tracer.value(r,"empty",t,void 0),t=void 0);const u=c.presence||l._flags.presence||(l._flags._endedSwitch?null:i.presence);if(t===void 0){if(u==="forbidden")return s.finalize(t,null,y);if(u==="required")return s.finalize(t,[l.$_createError("any.required",t,null,r,i)],y);if(u==="optional"){if(l._flags.default!==e.symbols.deepDefault)return s.finalize(t,null,y);r.mainstay.tracer.value(r,"default",t,{}),t={}}}else if(u==="forbidden")return s.finalize(t,[l.$_createError("any.unknown",t,null,r,i)],y);const m=[];if(l._valids){const h=l._valids.get(t,r,i,l._flags.insensitive);if(h)return i.convert&&(r.mainstay.tracer.value(r,"valids",t,h.value),t=h.value),r.mainstay.tracer.filter(l,r,"valid",h),s.finalize(t,null,y);if(l._flags.only){const $=l.$_createError("any.only",t,{valids:l._valids.values({display:!0})},r,i);if(i.abortEarly)return s.finalize(t,[$],y);m.push($)}}if(l._invalids){const h=l._invalids.get(t,r,i,l._flags.insensitive);if(h){r.mainstay.tracer.filter(l,r,"invalid",h);const $=l.$_createError("any.invalid",t,{invalids:l._invalids.values({display:!0})},r,i);if(i.abortEarly)return s.finalize(t,[$],y);m.push($)}}if(x.validate){const h=x.validate(t,y);if(h&&(r.mainstay.tracer.value(r,"base",t,h.value),t=h.value,h.errors)){if(!Array.isArray(h.errors))return m.push(h.errors),s.finalize(t,m,y);if(h.errors.length)return m.push(...h.errors),s.finalize(t,m,y)}}return l._rules.length?s.rules(t,m,y):s.finalize(t,m,y)},s.rules=function(t,l,r){const{schema:i,state:c,prefs:d}=r;for(const y of i._rules){const x=i._definition.rules[y.method];if(x.convert&&d.convert){c.mainstay.tracer.log(i,c,"rule",y.name,"full");continue}let _,u=y.args;if(y._resolve.length){u=Object.assign({},u);for(const h of y._resolve){const $=x.argsByName.get(h),j=u[h].resolve(t,c,d),E=$.normalize?$.normalize(j):j,N=e.validateArg(E,null,$);if(N){_=i.$_createError("any.ref",j,{arg:h,ref:u[h],reason:N},c,d);break}u[h]=E}}_=_||x.validate(t,r,u,y);const m=s.rule(_,y);if(m.errors){if(c.mainstay.tracer.log(i,c,"rule",y.name,"error"),y.warn){c.mainstay.warnings.push(...m.errors);continue}if(d.abortEarly)return s.finalize(t,m.errors,r);l.push(...m.errors)}else c.mainstay.tracer.log(i,c,"rule",y.name,"pass"),c.mainstay.tracer.value(c,"rule",t,m.value,y.name),t=m.value}return s.finalize(t,l,r)},s.rule=function(t,l){return t instanceof n.Report?(s.error(t,l),{errors:[t],value:null}):Array.isArray(t)&&t[e.symbols.errors]?(t.forEach(r=>s.error(r,l)),{errors:t,value:null}):{errors:null,value:t}},s.error=function(t,l){return l.message&&t._setTemplate(l.message),t},s.finalize=function(t,l,r){l=l||[];const{schema:i,state:c,prefs:d}=r;if(l.length){const x=s.default("failover",void 0,l,r);x!==void 0&&(c.mainstay.tracer.value(c,"failover",t,x),t=x,l=[])}if(l.length&&i._flags.error)if(typeof i._flags.error=="function"){l=i._flags.error(l),Array.isArray(l)||(l=[l]);for(const x of l)o(x instanceof Error||x instanceof n.Report,"error() must return an Error object")}else l=[i._flags.error];if(t===void 0){const x=s.default("default",t,l,r);c.mainstay.tracer.value(c,"default",t,x),t=x}if(i._flags.cast&&t!==void 0){const x=i._definition.cast[i._flags.cast];if(x.from(t)){const _=x.to(t,r);c.mainstay.tracer.value(c,"cast",t,_,i._flags.cast),t=_}}if(i.$_terms.externals&&d.externals&&d._externals!==!1)for(const{method:x}of i.$_terms.externals)c.mainstay.externals.push({method:x,path:c.path,label:n.label(i._flags,c,d)});const y={value:t,errors:l.length?l:null};return i._flags.result&&(y.value=i._flags.result==="strip"?void 0:r.original,c.mainstay.tracer.value(c,i._flags.result,t,y.value),c.shadow(t,i._flags.result)),i._cache&&d.cache!==!1&&!i._refs.length&&i._cache.set(r.original,y),t===void 0||y.errors||i._flags.artifact===void 0||(c.mainstay.artifacts=c.mainstay.artifacts||new Map,c.mainstay.artifacts.has(i._flags.artifact)||c.mainstay.artifacts.set(i._flags.artifact,[]),c.mainstay.artifacts.get(i._flags.artifact).push(c.path)),y},s.prefs=function(t,l){const r=l===e.defaults;return r&&t._preferences[e.symbols.prefs]?t._preferences[e.symbols.prefs]:(l=e.preferences(l,t._preferences),r&&(t._preferences[e.symbols.prefs]=l),l)},s.default=function(t,l,r,i){const{schema:c,state:d,prefs:y}=i,x=c._flags[t];if(y.noDefaults||x===void 0)return l;if(d.mainstay.tracer.log(c,d,"rule",t,"full"),!x)return x;if(typeof x=="function"){const _=x.length?[v(d.ancestors[0]),i]:[];try{return x(..._)}catch(u){return void r.push(c.$_createError(`any.${t}`,null,{error:u},d,y))}}return typeof x!="object"?x:x[e.symbols.literal]?x.literal:e.isResolvable(x)?x.resolve(l,d,y):v(x)},s.trim=function(t,l){if(typeof t!="string")return t;const r=l.$_getRule("trim");return r&&r.args.enabled?t.trim():t},s.ignore={active:!1,debug:g,entry:g,filter:g,log:g,resolve:g,value:g},s.errorsArray=function(){const t=[];return t[e.symbols.errors]=!0,t}},2036:(S,w,b)=>{const o=b(375),v=b(9474),g=b(8160),f={};S.exports=f.Values=class{constructor(e,n){this._values=new Set(e),this._refs=new Set(n),this._lowercase=f.lowercases(e),this._override=!1}get length(){return this._values.size+this._refs.size}add(e,n){g.isResolvable(e)?this._refs.has(e)||(this._refs.add(e),n&&n.register(e)):this.has(e,null,null,!1)||(this._values.add(e),typeof e=="string"&&this._lowercase.set(e.toLowerCase(),e))}static merge(e,n,a){if(e=e||new f.Values,n){if(n._override)return n.clone();for(const s of[...n._values,...n._refs])e.add(s)}if(a)for(const s of[...a._values,...a._refs])e.remove(s);return e.length?e:null}remove(e){g.isResolvable(e)?this._refs.delete(e):(this._values.delete(e),typeof e=="string"&&this._lowercase.delete(e.toLowerCase()))}has(e,n,a,s){return!!this.get(e,n,a,s)}get(e,n,a,s){if(!this.length)return!1;if(this._values.has(e))return{value:e};if(typeof e=="string"&&e&&s){const t=this._lowercase.get(e.toLowerCase());if(t)return{value:t}}if(!this._refs.size&&typeof e!="object")return!1;if(typeof e=="object"){for(const t of this._values)if(v(t,e))return{value:t}}if(n)for(const t of this._refs){const l=t.resolve(e,n,a,null,{in:!0});if(l===void 0)continue;const r=t.in&&typeof l=="object"?Array.isArray(l)?l:Object.keys(l):[l];for(const i of r)if(typeof i==typeof e){if(s&&e&&typeof e=="string"){if(i.toLowerCase()===e.toLowerCase())return{value:i,ref:t}}else if(v(i,e))return{value:i,ref:t}}}return!1}override(){this._override=!0}values(e){if(e&&e.display){const n=[];for(const a of[...this._values,...this._refs])a!==void 0&&n.push(a);return n}return Array.from([...this._values,...this._refs])}clone(){const e=new f.Values(this._values,this._refs);return e._override=this._override,e}concat(e){o(!e._override,"Cannot concat override set of values");const n=new f.Values([...this._values,...e._values],[...this._refs,...e._refs]);return n._override=this._override,n}describe(){const e=[];this._override&&e.push({override:!0});for(const n of this._values.values())e.push(n&&typeof n=="object"?{value:n}:n);for(const n of this._refs.values())e.push(n.describe());return e}},f.Values.prototype[g.symbols.values]=!0,f.Values.prototype.slice=f.Values.prototype.clone,f.lowercases=function(e){const n=new Map;if(e)for(const a of e)typeof a=="string"&&n.set(a.toLowerCase(),a);return n}},978:(S,w,b)=>{const o=b(375),v=b(8571),g=b(1687),f=b(9621),e={};S.exports=function(n,a){let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(o(n&&typeof n=="object","Invalid defaults value: must be an object"),o(!a||a===!0||typeof a=="object","Invalid source value: must be true, falsy or an object"),o(typeof s=="object","Invalid options: must be an object"),!a)return null;if(s.shallow)return e.applyToDefaultsWithShallow(n,a,s);const t=v(n);if(a===!0)return t;const l=s.nullOverride!==void 0&&s.nullOverride;return g(t,a,{nullOverride:l,mergeArrays:!1})},e.applyToDefaultsWithShallow=function(n,a,s){const t=s.shallow;o(Array.isArray(t),"Invalid keys");const l=new Map,r=a===!0?null:new Set;for(let d of t){d=Array.isArray(d)?d:d.split(".");const y=f(n,d);y&&typeof y=="object"?l.set(y,r&&f(a,d)||y):r&&r.add(d)}const i=v(n,{},l);if(!r)return i;for(const d of r)e.reachCopy(i,a,d);const c=s.nullOverride!==void 0&&s.nullOverride;return g(i,a,{nullOverride:c,mergeArrays:!1})},e.reachCopy=function(n,a,s){for(const r of s){if(!(r in a))return;const i=a[r];if(typeof i!="object"||i===null)return;a=i}const t=a;let l=n;for(let r=0;r<s.length-1;++r){const i=s[r];typeof l[i]!="object"&&(l[i]={}),l=l[i]}l[s[s.length-1]]=t}},375:(S,w,b)=>{const o=b(7916);S.exports=function(v){if(!v){for(var g=arguments.length,f=new Array(g>1?g-1:0),e=1;e<g;e++)f[e-1]=arguments[e];throw f.length===1&&f[0]instanceof Error?f[0]:new o(f)}}},8571:(S,w,b)=>{const o=b(9621),v=b(4277),g=b(7043),f={needsProtoHack:new Set([v.set,v.map,v.weakSet,v.weakMap])};S.exports=f.clone=function(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;if(typeof e!="object"||e===null)return e;let s=f.clone,t=a;if(n.shallow){if(n.shallow!==!0)return f.cloneWithShallow(e,n);s=D(c=>c,"s")}else if(t){const c=t.get(e);if(c)return c}else t=new Map;const l=v.getInternalProto(e);if(l===v.buffer)return!1;if(l===v.date)return new Date(e.getTime());if(l===v.regex)return new RegExp(e);const r=f.base(e,l,n);if(r===e)return e;if(t&&t.set(e,r),l===v.set)for(const c of e)r.add(s(c,n,t));else if(l===v.map)for(const[c,d]of e)r.set(c,s(d,n,t));const i=g.keys(e,n);for(const c of i){if(c==="__proto__")continue;if(l===v.array&&c==="length"){r.length=e.length;continue}const d=Object.getOwnPropertyDescriptor(e,c);d?d.get||d.set?Object.defineProperty(r,c,d):d.enumerable?r[c]=s(e[c],n,t):Object.defineProperty(r,c,{enumerable:!1,writable:!0,configurable:!0,value:s(e[c],n,t)}):Object.defineProperty(r,c,{enumerable:!0,writable:!0,configurable:!0,value:s(e[c],n,t)})}return r},f.cloneWithShallow=function(e,n){const a=n.shallow;(n=Object.assign({},n)).shallow=!1;const s=new Map;for(const t of a){const l=o(e,t);typeof l!="object"&&typeof l!="function"||s.set(l,l)}return f.clone(e,n,s)},f.base=function(e,n,a){if(a.prototype===!1)return f.needsProtoHack.has(n)?new n.constructor:n===v.array?[]:{};const s=Object.getPrototypeOf(e);if(s&&s.isImmutable)return e;if(n===v.array){const t=[];return s!==n&&Object.setPrototypeOf(t,s),t}if(f.needsProtoHack.has(n)){const t=new s.constructor;return s!==n&&Object.setPrototypeOf(t,s),t}return Object.create(s)}},9474:(S,w,b)=>{const o=b(4277),v={mismatched:null};S.exports=function(g,f,e){return e=Object.assign({prototype:!0},e),!!v.isDeepEqual(g,f,e,[])},v.isDeepEqual=function(g,f,e,n){if(g===f)return g!==0||1/g==1/f;const a=typeof g;if(a!==typeof f||g===null||f===null)return!1;if(a==="function"){if(!e.deepFunction||g.toString()!==f.toString())return!1}else if(a!=="object")return g!=g&&f!=f;const s=v.getSharedType(g,f,!!e.prototype);switch(s){case o.buffer:return!1;case o.promise:return g===f;case o.regex:return g.toString()===f.toString();case v.mismatched:return!1}for(let t=n.length-1;t>=0;--t)if(n[t].isSame(g,f))return!0;n.push(new v.SeenEntry(g,f));try{return!!v.isDeepEqualObj(s,g,f,e,n)}finally{n.pop()}},v.getSharedType=function(g,f,e){if(e)return Object.getPrototypeOf(g)!==Object.getPrototypeOf(f)?v.mismatched:o.getInternalProto(g);const n=o.getInternalProto(g);return n!==o.getInternalProto(f)?v.mismatched:n},v.valueOf=function(g){const f=g.valueOf;if(f===void 0)return g;try{return f.call(g)}catch(e){return e}},v.hasOwnEnumerableProperty=function(g,f){return Object.prototype.propertyIsEnumerable.call(g,f)},v.isSetSimpleEqual=function(g,f){for(const e of Set.prototype.values.call(g))if(!Set.prototype.has.call(f,e))return!1;return!0},v.isDeepEqualObj=function(g,f,e,n,a){const{isDeepEqual:s,valueOf:t,hasOwnEnumerableProperty:l}=v,{keys:r,getOwnPropertySymbols:i}=Object;if(g===o.array){if(!n.part){if(f.length!==e.length)return!1;for(let _=0;_<f.length;++_)if(!s(f[_],e[_],n,a))return!1;return!0}for(const _ of f)for(const u of e)if(s(_,u,n,a))return!0}else if(g===o.set){if(f.size!==e.size)return!1;if(!v.isSetSimpleEqual(f,e)){const _=new Set(Set.prototype.values.call(e));for(const u of Set.prototype.values.call(f)){if(_.delete(u))continue;let m=!1;for(const h of _)if(s(u,h,n,a)){_.delete(h),m=!0;break}if(!m)return!1}}}else if(g===o.map){if(f.size!==e.size)return!1;for(const[_,u]of Map.prototype.entries.call(f))if(u===void 0&&!Map.prototype.has.call(e,_)||!s(u,Map.prototype.get.call(e,_),n,a))return!1}else if(g===o.error&&(f.name!==e.name||f.message!==e.message))return!1;const c=t(f),d=t(e);if((f!==c||e!==d)&&!s(c,d,n,a))return!1;const y=r(f);if(!n.part&&y.length!==r(e).length&&!n.skip)return!1;let x=0;for(const _ of y)if(n.skip&&n.skip.includes(_))e[_]===void 0&&++x;else if(!l(e,_)||!s(f[_],e[_],n,a))return!1;if(!n.part&&y.length-x!==r(e).length)return!1;if(n.symbols!==!1){const _=i(f),u=new Set(i(e));for(const m of _){if(!n.skip||!n.skip.includes(m)){if(l(f,m)){if(!l(e,m)||!s(f[m],e[m],n,a))return!1}else if(l(e,m))return!1}u.delete(m)}for(const m of u)if(l(e,m))return!1}return!0},v.SeenEntry=class{constructor(g,f){this.obj=g,this.ref=f}isSame(g,f){return this.obj===g&&this.ref===f}}},7916:(S,w,b)=>{const o=b(8761);S.exports=class extends Error{constructor(v){super(v.filter(g=>g!=="").map(g=>typeof g=="string"?g:g instanceof Error?g.message:o(g)).join(" ")||"Unknown error"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.assert)}}},5277:S=>{const w={};S.exports=function(b){if(!b)return"";let o="";for(let v=0;v<b.length;++v){const g=b.charCodeAt(v);w.isSafe(g)?o+=b[v]:o+=w.escapeHtmlChar(g)}return o},w.escapeHtmlChar=function(b){return w.namedHtml.get(b)||(b>=256?"&#"+b+";":`&#x${b.toString(16).padStart(2,"0")};`)},w.isSafe=function(b){return w.safeCharCodes.has(b)},w.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),w.safeCharCodes=function(){const b=new Set;for(let o=32;o<123;++o)(o>=97||o>=65&&o<=90||o>=48&&o<=57||o===32||o===46||o===44||o===45||o===58||o===95)&&b.add(o);return b}()},6064:S=>{S.exports=function(w){return w.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:S=>{S.exports=function(){}},1687:(S,w,b)=>{const o=b(375),v=b(8571),g=b(7043),f={};S.exports=f.merge=function(e,n,a){if(o(e&&typeof e=="object","Invalid target value: must be an object"),o(n==null||typeof n=="object","Invalid source value: must be null, undefined, or an object"),!n)return e;if(a=Object.assign({nullOverride:!0,mergeArrays:!0},a),Array.isArray(n)){o(Array.isArray(e),"Cannot merge array onto an object"),a.mergeArrays||(e.length=0);for(let t=0;t<n.length;++t)e.push(v(n[t],{symbols:a.symbols}));return e}const s=g.keys(n,a);for(let t=0;t<s.length;++t){const l=s[t];if(l==="__proto__"||!Object.prototype.propertyIsEnumerable.call(n,l))continue;const r=n[l];if(r&&typeof r=="object"){if(e[l]===r)continue;!e[l]||typeof e[l]!="object"||Array.isArray(e[l])!==Array.isArray(r)||r instanceof Date||r instanceof RegExp?e[l]=v(r,{symbols:a.symbols}):f.merge(e[l],r,a)}else(r!=null||a.nullOverride)&&(e[l]=r)}return e}},9621:(S,w,b)=>{const o=b(375),v={};S.exports=function(g,f,e){if(f===!1||f==null)return g;typeof(e=e||{})=="string"&&(e={separator:e});const n=Array.isArray(f);o(!n||!e.separator,"Separator option is not valid for array-based chain");const a=n?f:f.split(e.separator||".");let s=g;for(let t=0;t<a.length;++t){let l=a[t];const r=e.iterables&&v.iterables(s);if(Array.isArray(s)||r==="set"){const i=Number(l);Number.isInteger(i)&&(l=i<0?s.length+i:i)}if(!s||typeof s=="function"&&e.functions===!1||!r&&s[l]===void 0){o(!e.strict||t+1===a.length,"Missing segment",l,"in reach path ",f),o(typeof s=="object"||e.functions===!0||typeof s!="function","Invalid segment",l,"in reach path ",f),s=e.default;break}s=r?r==="set"?[...s][l]:s.get(l):s[l]}return s},v.iterables=function(g){return g instanceof Set?"set":g instanceof Map?"map":void 0}},8761:S=>{S.exports=function(){try{return JSON.stringify(...arguments)}catch(w){return"[Cannot display object: "+w.message+"]"}}},4277:(S,w)=>{const b={};w=S.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},b.typeMap=new Map([["[object Error]",w.error],["[object Map]",w.map],["[object Promise]",w.promise],["[object Set]",w.set],["[object WeakMap]",w.weakMap],["[object WeakSet]",w.weakSet]]),w.getInternalProto=function(o){if(Array.isArray(o))return w.array;if(o instanceof Date)return w.date;if(o instanceof RegExp)return w.regex;if(o instanceof Error)return w.error;const v=Object.prototype.toString.call(o);return b.typeMap.get(v)||w.generic}},7043:(S,w)=>{w.keys=function(b){return(arguments.length>1&&arguments[1]!==void 0?arguments[1]:{}).symbols!==!1?Reflect.ownKeys(b):Object.getOwnPropertyNames(b)}},3652:(S,w,b)=>{const o=b(375),v={};w.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(g,f){const e=[].concat((f=f||{}).before||[]),n=[].concat(f.after||[]),a=f.group||"?",s=f.sort||0;o(!e.includes(a),`Item cannot come before itself: ${a}`),o(!e.includes("?"),"Item cannot come before unassociated items"),o(!n.includes(a),`Item cannot come after itself: ${a}`),o(!n.includes("?"),"Item cannot come after unassociated items"),Array.isArray(g)||(g=[g]);for(const t of g){const l={seq:this._items.length,sort:s,before:e,after:n,group:a,node:t};this._items.push(l)}if(!f.manual){const t=this._sort();o(t,"item",a!=="?"?`added into group ${a}`:"","created a dependencies error")}return this.nodes}merge(g){Array.isArray(g)||(g=[g]);for(const e of g)if(e)for(const n of e._items)this._items.push(Object.assign({},n));this._items.sort(v.mergeSort);for(let e=0;e<this._items.length;++e)this._items[e].seq=e;const f=this._sort();return o(f,"merge created a dependencies error"),this.nodes}sort(){const g=this._sort();return o(g,"sort created a dependencies error"),this.nodes}_sort(){const g={},f=Object.create(null),e=Object.create(null);for(const l of this._items){const r=l.seq,i=l.group;e[i]=e[i]||[],e[i].push(r),g[r]=l.before;for(const c of l.after)f[c]=f[c]||[],f[c].push(r)}for(const l in g){const r=[];for(const i in g[l]){const c=g[l][i];e[c]=e[c]||[],r.push(...e[c])}g[l]=r}for(const l in f)if(e[l])for(const r of e[l])g[r].push(...f[l]);const n={};for(const l in g){const r=g[l];for(const i of r)n[i]=n[i]||[],n[i].push(l)}const a={},s=[];for(let l=0;l<this._items.length;++l){let r=l;if(n[l]){r=null;for(let i=0;i<this._items.length;++i){if(a[i]===!0)continue;n[i]||(n[i]=[]);const c=n[i].length;let d=0;for(let y=0;y<c;++y)a[n[i][y]]&&++d;if(d===c){r=i;break}}}r!==null&&(a[r]=!0,s.push(r))}if(s.length!==this._items.length)return!1;const t={};for(const l of this._items)t[l.seq]=l;this._items=[],this.nodes=[];for(const l of s){const r=t[l];this.nodes.push(r.node),this._items.push(r)}return!0}},v.mergeSort=(g,f)=>g.sort===f.sort?0:g.sort<f.sort?-1:1},5380:(S,w,b)=>{const o=b(443),v=b(2178),g={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:o.URL||URL};w.analyze=function(f){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!f)return v.code("DOMAIN_NON_EMPTY_STRING");if(typeof f!="string")throw new Error("Invalid input: domain must be a string");if(f.length>256)return v.code("DOMAIN_TOO_LONG");if(!!g.nonAsciiRx.test(f)){if(e.allowUnicode===!1)return v.code("DOMAIN_INVALID_UNICODE_CHARS");f=f.normalize("NFC")}if(g.domainControlRx.test(f))return v.code("DOMAIN_INVALID_CHARS");f=g.punycode(f),e.allowFullyQualified&&f[f.length-1]==="."&&(f=f.slice(0,-1));const a=e.minDomainSegments||g.minDomainSegments,s=f.split(".");if(s.length<a)return v.code("DOMAIN_SEGMENTS_COUNT");if(e.maxDomainSegments&&s.length>e.maxDomainSegments)return v.code("DOMAIN_SEGMENTS_COUNT_MAX");const t=e.tlds;if(t){const l=s[s.length-1].toLowerCase();if(t.deny&&t.deny.has(l)||t.allow&&!t.allow.has(l))return v.code("DOMAIN_FORBIDDEN_TLDS")}for(let l=0;l<s.length;++l){const r=s[l];if(!r.length)return v.code("DOMAIN_EMPTY_SEGMENT");if(r.length>63)return v.code("DOMAIN_LONG_SEGMENT");if(l<s.length-1){if(!g.domainSegmentRx.test(r))return v.code("DOMAIN_INVALID_CHARS")}else if(!g.tldSegmentRx.test(r))return v.code("DOMAIN_INVALID_TLDS_CHARS")}return null},w.isValid=function(f,e){return!w.analyze(f,e)},g.punycode=function(f){f.includes("%")&&(f=f.replace(/%/g,"%25"));try{return new g.URL(`http://${f}`).host}catch{return f}}},1745:(S,w,b)=>{const o=b(9848),v=b(5380),g=b(2178),f={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(o.TextEncoder||TextEncoder)};w.analyze=function(e,n){return f.email(e,n)},w.isValid=function(e,n){return!f.email(e,n)},f.email=function(e){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(typeof e!="string")throw new Error("Invalid input: email must be a string");if(!e)return g.code("EMPTY_STRING");const a=!f.nonAsciiRx.test(e);if(!a){if(n.allowUnicode===!1)return g.code("FORBIDDEN_UNICODE");e=e.normalize("NFC")}const s=e.split("@");if(s.length!==2)return s.length>2?g.code("MULTIPLE_AT_CHAR"):g.code("MISSING_AT_CHAR");const[t,l]=s;if(!t)return g.code("EMPTY_LOCAL");if(!n.ignoreLength){if(e.length>254)return g.code("ADDRESS_TOO_LONG");if(f.encoder.encode(t).length>64)return g.code("LOCAL_TOO_LONG")}return f.local(t,a)||v.analyze(l,n)},f.local=function(e,n){const a=e.split(".");for(const s of a){if(!s.length)return g.code("EMPTY_LOCAL_SEGMENT");if(n){if(!f.atextRx.test(s))return g.code("INVALID_LOCAL_CHARS")}else for(const t of s){if(f.atextRx.test(t))continue;const l=f.binary(t);if(!f.atomRx.test(l))return g.code("INVALID_LOCAL_CHARS")}}},f.binary=function(e){return Array.from(f.encoder.encode(e)).map(n=>String.fromCharCode(n)).join("")},f.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,f.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(S,w)=>{w.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},w.code=function(b){return{code:b,error:w.codes[b]}}},9959:(S,w,b)=>{const o=b(375),v=b(5752);w.regex=function(){let g=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};o(g.cidr===void 0||typeof g.cidr=="string","options.cidr must be a string");const f=g.cidr?g.cidr.toLowerCase():"optional";o(["required","optional","forbidden"].includes(f),"options.cidr must be one of required, optional, forbidden"),o(g.version===void 0||typeof g.version=="string"||Array.isArray(g.version),"options.version must be a string or an array of string");let e=g.version||["ipv4","ipv6","ipvfuture"];Array.isArray(e)||(e=[e]),o(e.length>=1,"options.version must have at least 1 version specified");for(let t=0;t<e.length;++t)o(typeof e[t]=="string","options.version must only contain strings"),e[t]=e[t].toLowerCase(),o(["ipv4","ipv6","ipvfuture"].includes(e[t]),"options.version contains unknown version "+e[t]+" - must be one of ipv4, ipv6, ipvfuture");e=Array.from(new Set(e));const n=e.map(t=>{if(f==="forbidden")return v.ip[t];const l=`\\/${t==="ipv4"?v.ip.v4Cidr:v.ip.v6Cidr}`;return f==="required"?`${v.ip[t]}${l}`:`${v.ip[t]}(?:${l})?`}),a=`(?:${n.join("|")})`,s=new RegExp(`^${a}$`);return{cidr:f,versions:e,regex:s,raw:a}}},5752:(S,w,b)=>{const o=b(375),v=b(6064),g={generate:function(){const f={},e="!\\$&'\\(\\)\\*\\+,;=",n="\\w-\\.~%\\dA-Fa-f"+e+":@",a="["+n+"]",s="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";f.ipv4address="(?:"+s+"\\.){3}"+s;const t="[\\dA-Fa-f]{1,4}",l="(?:"+t+":"+t+"|"+f.ipv4address+")",r="(?:"+t+":){6}"+l,i="::(?:"+t+":){5}"+l,c="(?:"+t+")?::(?:"+t+":){4}"+l,d="(?:(?:"+t+":){0,1}"+t+")?::(?:"+t+":){3}"+l,y="(?:(?:"+t+":){0,2}"+t+")?::(?:"+t+":){2}"+l,x="(?:(?:"+t+":){0,3}"+t+")?::"+t+":"+l,_="(?:(?:"+t+":){0,4}"+t+")?::"+l;f.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",f.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",f.ipv6address="(?:"+r+"|"+i+"|"+c+"|"+d+"|"+y+"|"+x+"|"+_+"|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)",f.ipvFuture="v[\\dA-Fa-f]+\\.[\\w-\\.~"+e+":]+",f.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",f.schemeRegex=new RegExp(f.scheme);const u="[\\w-\\.~%\\dA-Fa-f"+e+":]*",m="(?:\\[(?:"+f.ipv6address+"|"+f.ipvFuture+")\\]|"+f.ipv4address+"|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})",h="(?:"+u+"@)?"+m+"(?::\\d*)?",$="(?:"+u+"@)?("+m+")(?::\\d*)?",j=a+"+",E="(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*",N="\\/(?:"+j+E+")?",M=j+E,V="[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=@]+"+E;return f.hierPart="(?:(?:\\/\\/"+h+E+")|"+N+"|"+M+"|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))",f.hierPartCapture="(?:(?:\\/\\/"+$+E+")|"+N+"|"+M+")",f.relativeRef="(?:(?:\\/\\/"+h+E+")|"+N+"|"+V+"|)",f.relativeRefCapture="(?:(?:\\/\\/"+$+E+")|"+N+"|"+V+"|)",f.query="["+n+"\\/\\?]*(?=#|$)",f.queryWithSquareBrackets="["+n+"\\[\\]\\/\\?]*(?=#|$)",f.fragment="["+n+"\\/\\?]*",f}};g.rfc3986=g.generate(),w.ip={v4Cidr:g.rfc3986.ipv4Cidr,v6Cidr:g.rfc3986.ipv6Cidr,ipv4:g.rfc3986.ipv4address,ipv6:g.rfc3986.ipv6address,ipvfuture:g.rfc3986.ipvFuture},g.createRegex=function(f){const e=g.rfc3986,n="(?:\\?"+(f.allowQuerySquareBrackets?e.queryWithSquareBrackets:e.query)+")?(?:#"+e.fragment+")?",a=f.domain?e.relativeRefCapture:e.relativeRef;if(f.relativeOnly)return g.wrap(a+n);let s="";if(f.scheme){o(f.scheme instanceof RegExp||typeof f.scheme=="string"||Array.isArray(f.scheme),"scheme must be a RegExp, String, or Array");const r=[].concat(f.scheme);o(r.length>=1,"scheme must have at least 1 scheme specified");const i=[];for(let c=0;c<r.length;++c){const d=r[c];o(d instanceof RegExp||typeof d=="string","scheme at position "+c+" must be a RegExp or String"),d instanceof RegExp?i.push(d.source.toString()):(o(e.schemeRegex.test(d),"scheme at position "+c+" must be a valid scheme"),i.push(v(d)))}s=i.join("|")}const t="(?:"+(s?"(?:"+s+")":e.scheme)+":"+(f.domain?e.hierPartCapture:e.hierPart)+")",l=f.allowRelative?"(?:"+t+"|"+a+")":t;return g.wrap(l+n,s)},g.wrap=function(f,e){return{raw:f=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${f}`,regex:new RegExp(`^${f}$`),scheme:e}},g.uriRegex=g.createRegex({}),w.regex=function(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return f.scheme||f.allowRelative||f.relativeOnly||f.allowQuerySquareBrackets||f.domain?g.createRegex(f):g.uriRegex}},1447:(S,w)=>{const b={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*\.?[0-9]*){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};w.Parser=class{constructor(o){let v=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!v[b.settings]&&v.constants)for(const g in v.constants){const f=v.constants[g];if(f!==null&&!["boolean","number","string"].includes(typeof f))throw new Error(`Formula constant ${g} contains invalid ${typeof f} value type`)}this.settings=v[b.settings]?v:Object.assign({[b.settings]:!0,constants:{},functions:{}},v),this.single=null,this._parts=null,this._parse(o)}_parse(o){let v=[],g="",f=0,e=!1;const n=D(s=>{if(f)throw new Error("Formula missing closing parenthesis");const t=v.length?v[v.length-1]:null;if(e||g||s){if(t&&t.type==="reference"&&s===")")return t.type="function",t.value=this._subFormula(g,t.value),void(g="");if(s===")"){const l=new w.Parser(g,this.settings);v.push({type:"segment",value:l})}else if(e){if(e==="]")return v.push({type:"reference",value:g}),void(g="");v.push({type:"literal",value:g})}else if(b.operatorCharacters.includes(g))t&&t.type==="operator"&&b.operators.includes(t.value+g)?t.value+=g:v.push({type:"operator",value:g});else if(g.match(b.numberRx))v.push({type:"constant",value:parseFloat(g)});else if(this.settings.constants[g]!==void 0)v.push({type:"constant",value:this.settings.constants[g]});else{if(!g.match(b.tokenRx))throw new Error(`Formula contains invalid token: ${g}`);v.push({type:"reference",value:g})}g=""}},"o");for(const s of o)e?s===e?(n(),e=!1):g+=s:f?s==="("?(g+=s,++f):s===")"?(--f,f?g+=s:n(s)):g+=s:s in b.literals?e=b.literals[s]:s==="("?(n(),++f):b.operatorCharacters.includes(s)?(n(),g=s,n()):s!==" "?g+=s:n();n(),v=v.map((s,t)=>s.type!=="operator"||s.value!=="-"||t&&v[t-1].type!=="operator"?s:{type:"operator",value:"n"});let a=!1;for(const s of v){if(s.type==="operator"){if(b.operatorsPrefix.includes(s.value))continue;if(!a)throw new Error("Formula contains an operator in invalid position");if(!b.operators.includes(s.value))throw new Error(`Formula contains an unknown operator ${s.value}`)}else if(a)throw new Error("Formula missing expected operator");a=!a}if(!a)throw new Error("Formula contains invalid trailing operator");v.length===1&&["reference","literal","constant"].includes(v[0].type)&&(this.single={type:v[0].type==="reference"?"reference":"value",value:v[0].value}),this._parts=v.map(s=>{if(s.type==="operator")return b.operatorsPrefix.includes(s.value)?s:s.value;if(s.type!=="reference")return s.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(s.value))throw new Error(`Formula contains invalid reference ${s.value}`);return this.settings.reference?this.settings.reference(s.value):b.reference(s.value)})}_subFormula(o,v){const g=this.settings.functions[v];if(typeof g!="function")throw new Error(`Formula contains unknown function ${v}`);let f=[];if(o){let e="",n=0,a=!1;const s=D(()=>{if(!e)throw new Error(`Formula contains function ${v} with invalid arguments ${o}`);f.push(e),e=""},"o");for(let t=0;t<o.length;++t){const l=o[t];a?(e+=l,l===a&&(a=!1)):l in b.literals&&!n?(e+=l,a=b.literals[l]):l!==","||n?(e+=l,l==="("?++n:l===")"&&--n):s()}s()}return f=f.map(e=>new w.Parser(e,this.settings)),function(e){const n=[];for(const a of f)n.push(a.evaluate(e));return g.call(e,...n)}}evaluate(o){const v=this._parts.slice();for(let g=v.length-2;g>=0;--g){const f=v[g];if(f&&f.type==="operator"){const e=v[g+1];v.splice(g+1,1);const n=b.evaluate(e,o);v[g]=b.single(f.value,n)}}return b.operatorsOrder.forEach(g=>{for(let f=1;f<v.length-1;)if(g.includes(v[f])){const e=v[f],n=b.evaluate(v[f-1],o),a=b.evaluate(v[f+1],o);v.splice(f,2);const s=b.calculate(e,n,a);v[f-1]=s===0?0:s}else f+=2}),b.evaluate(v[0],o)}},w.Parser.prototype[b.symbol]=!0,b.reference=function(o){return function(v){return v&&v[o]!==void 0?v[o]:null}},b.evaluate=function(o,v){return o===null?null:typeof o=="function"?o(v):o[b.symbol]?o.evaluate(v):o},b.single=function(o,v){if(o==="!")return!v;const g=-v;return g===0?0:g},b.calculate=function(o,v,g){if(o==="??")return b.exists(v)?v:g;if(typeof v=="string"||typeof g=="string"){if(o==="+")return(v=b.exists(v)?v:"")+(b.exists(g)?g:"")}else switch(o){case"^":return Math.pow(v,g);case"*":return v*g;case"/":return v/g;case"%":return v%g;case"+":return v+g;case"-":return v-g}switch(o){case"<":return v<g;case"<=":return v<=g;case">":return v>g;case">=":return v>=g;case"==":return v===g;case"!=":return v!==g;case"&&":return v&&g;case"||":return v||g}return null},b.exists=function(o){return o!=null}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:S=>{S.exports={version:"17.7.0"}}},O={},D(function S(w){var b=O[w];if(b!==void 0)return b.exports;var o=O[w]={exports:{}};return A[w](o,o.exports,S),o.exports},"r")(5107);var A,O})})(st);const ce=st.exports;function nt(p){var k,A,O="";if(typeof p=="string"||typeof p=="number")O+=p;else if(typeof p=="object")if(Array.isArray(p))for(k=0;k<p.length;k++)p[k]&&(A=nt(p[k]))&&(O&&(O+=" "),O+=A);else for(k in p)p[k]&&(O&&(O+=" "),O+=k);return O}D(nt,"r");function at(){for(var p,k,A=0,O="";A<arguments.length;)(p=arguments[A++])&&(k=nt(p))&&(O&&(O+=" "),O+=k);return O}D(at,"clsx");var ke=D(p=>p.type==="checkbox","isCheckBoxInput"),_e=D(p=>p instanceof Date,"isDateObject"),X=D(p=>p==null,"isNullOrUndefined");const it=D(p=>typeof p=="object","isObjectType");var Y=D(p=>!X(p)&&!Array.isArray(p)&&it(p)&&!_e(p),"isObject"),wt=D(p=>Y(p)&&p.target?ke(p.target)?p.target.checked:p.target.value:p,"getEventValue"),xt=D(p=>p.substring(0,p.search(/\.\d+(\.|$)/))||p,"getNodeParentName"),$t=D((p,k)=>p.has(xt(k)),"isNameInFieldArray"),Se=D(p=>Array.isArray(p)?p.filter(Boolean):[],"compact"),Z=D(p=>p===void 0,"isUndefined"),T=D((p,k,A)=>{if(!k||!Y(p))return A;const O=Se(k.split(/[,[\].]+?/)).reduce((S,w)=>X(S)?S:S[w],p);return Z(O)||O===p?Z(p[k])?A:p[k]:O},"get");const Ge={BLUR:"blur",FOCUS_OUT:"focusout",CHANGE:"change"},ae={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},fe={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"},At=ue.createContext(null),kt=D(()=>ue.useContext(At),"useFormContext");var St=D((p,k,A,O=!0)=>{const S={defaultValues:k._defaultValues};for(const w in p)Object.defineProperty(S,w,{get:()=>{const b=w;return k._proxyFormState[b]!==ae.all&&(k._proxyFormState[b]=!O||ae.all),A&&(A[b]=!0),p[b]}});return S},"getProxyFormState"),re=D(p=>Y(p)&&!Object.keys(p).length,"isEmptyObject"),Rt=D((p,k,A)=>{const{name:O,...S}=p;return re(S)||Object.keys(S).length>=Object.keys(k).length||Object.keys(S).find(w=>k[w]===(!A||ae.all))},"shouldRenderFormState"),Ie=D(p=>Array.isArray(p)?p:[p],"convertToArrayPayload");function jt(p){const k=ue.useRef(p);k.current=p,ue.useEffect(()=>{const A=!p.disabled&&k.current.subject.subscribe({next:k.current.callback});return()=>{A&&A.unsubscribe()}},[p.disabled])}D(jt,"useSubscribe");var ie=D(p=>typeof p=="string","isString"),Ot=D((p,k,A,O)=>{const S=Array.isArray(p);return ie(p)?(O&&k.watch.add(p),T(A,p)):S?p.map(w=>(O&&k.watch.add(w),T(A,w))):(O&&(k.watchAll=!0),A)},"generateWatchOutput"),Oe=D(p=>typeof p=="function","isFunction"),ot=D(p=>{for(const k in p)if(Oe(p[k]))return!0;return!1},"objectHasFunction"),lt=D((p,k,A,O,S)=>k?{...A[p],types:{...A[p]&&A[p].types?A[p].types:{},[O]:S||!0}}:{},"appendErrors"),ze=D(p=>/^\w*$/.test(p),"isKey"),ct=D(p=>Se(p.replace(/["|']|\]/g,"").split(/\.|\[/)),"stringToPath");function U(p,k,A){let O=-1;const S=ze(k)?[k]:ct(k),w=S.length,b=w-1;for(;++O<w;){const o=S[O];let v=A;if(O!==b){const g=p[o];v=Y(g)||Array.isArray(g)?g:isNaN(+S[O+1])?{}:[]}p[o]=v,p=p[o]}return p}D(U,"set");const Pe=D((p,k,A)=>{for(const O of A||Object.keys(p)){const S=T(p,O);if(S){const{_f:w,...b}=S;if(w&&k(w.name)){if(w.ref.focus){w.ref.focus();break}else if(w.refs&&w.refs[0].focus){w.refs[0].focus();break}}else Y(b)&&Pe(b,k)}}},"focusFieldBy");var Ke=D((p,k,A)=>!A&&(k.watchAll||k.watch.has(p)||[...k.watch].some(O=>p.startsWith(O)&&/^\.\w+/.test(p.slice(O.length)))),"isWatched"),Et=D((p,k,A)=>{const O=Se(T(p,A));return U(O,"root",k[A]),U(p,A,O),p},"updateFieldArrayRootError"),Ae=D(p=>typeof p=="boolean","isBoolean"),Ue=D(p=>p.type==="file","isFileInput"),je=D(p=>ie(p)||ue.isValidElement(p),"isMessage"),Be=D(p=>p.type==="radio","isRadioInput"),Ee=D(p=>p instanceof RegExp,"isRegex");const Ze={value:!1,isValid:!1},Ye={value:!0,isValid:!0};var ut=D(p=>{if(Array.isArray(p)){if(p.length>1){const k=p.filter(A=>A&&A.checked&&!A.disabled).map(A=>A.value);return{value:k,isValid:!!k.length}}return p[0].checked&&!p[0].disabled?p[0].attributes&&!Z(p[0].attributes.value)?Z(p[0].value)||p[0].value===""?Ye:{value:p[0].value,isValid:!0}:Ye:Ze}return Ze},"getCheckboxValue");const Je={isValid:!1,value:null};var ft=D(p=>Array.isArray(p)?p.reduce((k,A)=>A&&A.checked&&!A.disabled?{isValid:!0,value:A.value}:k,Je):Je,"getRadioValue");function Qe(p,k,A="validate"){if(je(p)||Array.isArray(p)&&p.every(je)||Ae(p)&&!p)return{type:A,message:je(p)?p:"",ref:k}}D(Qe,"getValidateError");var ve=D(p=>Y(p)&&!Ee(p)?p:{value:p,message:""},"getValueAndMessage"),Xe=D(async(p,k,A,O,S)=>{const{ref:w,refs:b,required:o,maxLength:v,minLength:g,min:f,max:e,pattern:n,validate:a,name:s,valueAsNumber:t,mount:l,disabled:r}=p._f;if(!l||r)return{};const i=b?b[0]:w,c=D($=>{O&&ie($)&&(i.setCustomValidity($),i.reportValidity())},"setCustomValidity"),d={},y=Be(w),x=ke(w),_=y||x,u=(t||Ue(w))&&!w.value||k===""||Array.isArray(k)&&!k.length,m=lt.bind(null,s,A,d),h=D(($,j,E,N=fe.maxLength,M=fe.minLength)=>{const V=$?j:E;d[s]={type:$?N:M,message:V,ref:w,...m($?N:M,V)}},"getMinMaxMessage");if(S?!Array.isArray(k)||!k.length:o&&(!_&&(u||X(k))||Ae(k)&&!k||x&&!ut(b).isValid||y&&!ft(b).isValid)){const{value:$,message:j}=je(o)?{value:!!o,message:o}:ve(o);if($&&(d[s]={type:fe.required,message:j,ref:i,...m(fe.required,j)},!A))return c(j),d}if(!u&&(!X(f)||!X(e))){let $,j;const E=ve(e),N=ve(f);if(!X(k)&&!isNaN(k)){const M=w.valueAsNumber||k&&+k;X(E.value)||($=M>E.value),X(N.value)||(j=M<N.value)}else{const M=w.valueAsDate||new Date(k),V=D(ne=>new Date(new Date().toDateString()+" "+ne),"convertTimeToDate"),W=w.type=="time",K=w.type=="week";ie(E.value)&&k&&($=W?V(k)>V(E.value):K?k>E.value:M>new Date(E.value)),ie(N.value)&&k&&(j=W?V(k)<V(N.value):K?k<N.value:M<new Date(N.value))}if(($||j)&&(h(!!$,E.message,N.message,fe.max,fe.min),!A))return c(d[s].message),d}if((v||g)&&!u&&(ie(k)||S&&Array.isArray(k))){const $=ve(v),j=ve(g),E=!X($.value)&&k.length>$.value,N=!X(j.value)&&k.length<j.value;if((E||N)&&(h(E,$.message,j.message),!A))return c(d[s].message),d}if(n&&!u&&ie(k)){const{value:$,message:j}=ve(n);if(Ee($)&&!k.match($)&&(d[s]={type:fe.pattern,message:j,ref:w,...m(fe.pattern,j)},!A))return c(j),d}if(a){if(Oe(a)){const $=await a(k),j=Qe($,i);if(j&&(d[s]={...j,...m(fe.validate,j.message)},!A))return c(j.message),d}else if(Y(a)){let $={};for(const j in a){if(!re($)&&!A)break;const E=Qe(await a[j](k),i,j);E&&($={...E,...m(j,E.message)},c(E.message),A&&(d[s]=$))}if(!re($)&&(d[s]={ref:i,...$},!A))return d}}return c(!0),d},"validateField"),Dt=D(p=>{const k=p.constructor&&p.constructor.prototype;return Y(k)&&k.hasOwnProperty("isPrototypeOf")},"isPlainObject"),qe=typeof window<"u"&&typeof window.HTMLElement<"u"&&typeof document<"u";function ye(p){let k;const A=Array.isArray(p);if(p instanceof Date)k=new Date(p);else if(p instanceof Set)k=new Set(p);else if(!(qe&&(p instanceof Blob||p instanceof FileList))&&(A||Y(p)))if(k=A?[]:{},!Array.isArray(p)&&!Dt(p))k=p;else for(const O in p)k[O]=ye(p[O]);else return p;return k}D(ye,"cloneObject");var et=D(p=>({isOnSubmit:!p||p===ae.onSubmit,isOnBlur:p===ae.onBlur,isOnChange:p===ae.onChange,isOnAll:p===ae.all,isOnTouch:p===ae.onTouched}),"getValidationModes");function Ct(p,k){const A=k.slice(0,-1).length;let O=0;for(;O<A;)p=Z(p)?O++:p[k[O++]];return p}D(Ct,"baseGet");function Ft(p){for(const k in p)if(!Z(p[k]))return!1;return!0}D(Ft,"isEmptyArray");function Q(p,k){const A=ze(k)?[k]:ct(k),O=A.length==1?p:Ct(p,A),S=A[A.length-1];let w;O&&delete O[S];for(let b=0;b<A.slice(0,-1).length;b++){let o=-1,v;const g=A.slice(0,-(b+1)),f=g.length-1;for(b>0&&(w=p);++o<g.length;){const e=g[o];v=v?v[e]:p[e],f===o&&(Y(v)&&re(v)||Array.isArray(v)&&Ft(v))&&(w?delete w[e]:delete p[e]),w=v}}return p}D(Q,"unset");function Ne(){let p=[];return{get observers(){return p},next:D(S=>{for(const w of p)w.next(S)},"next"),subscribe:D(S=>(p.push(S),{unsubscribe:()=>{p=p.filter(w=>w!==S)}}),"subscribe"),unsubscribe:D(()=>{p=[]},"unsubscribe")}}D(Ne,"createSubject");var De=D(p=>X(p)||!it(p),"isPrimitive");function we(p,k){if(De(p)||De(k))return p===k;if(_e(p)&&_e(k))return p.getTime()===k.getTime();const A=Object.keys(p),O=Object.keys(k);if(A.length!==O.length)return!1;for(const S of A){const w=p[S];if(!O.includes(S))return!1;if(S!=="ref"){const b=k[S];if(_e(w)&&_e(b)||Y(w)&&Y(b)||Array.isArray(w)&&Array.isArray(b)?!we(w,b):w!==b)return!1}}return!0}D(we,"deepEqual");var Ve=D(p=>{const k=p?p.ownerDocument:0,A=k&&k.defaultView?k.defaultView.HTMLElement:HTMLElement;return p instanceof A},"isHTMLElement"),dt=D(p=>p.type==="select-multiple","isMultipleSelect"),It=D(p=>Be(p)||ke(p),"isRadioOrCheckbox"),Me=D(p=>Ve(p)&&p.isConnected,"live");function Ce(p,k={}){const A=Array.isArray(p);if(Y(p)||A)for(const O in p)Array.isArray(p[O])||Y(p[O])&&!ot(p[O])?(k[O]=Array.isArray(p[O])?[]:{},Ce(p[O],k[O])):X(p[O])||(k[O]=!0);return k}D(Ce,"markFieldsDirty");function mt(p,k,A){const O=Array.isArray(p);if(Y(p)||O)for(const S in p)Array.isArray(p[S])||Y(p[S])&&!ot(p[S])?Z(k)||De(A[S])?A[S]=Array.isArray(p[S])?Ce(p[S],[]):{...Ce(p[S])}:mt(p[S],X(k)?{}:k[S],A[S]):we(p[S],k[S])?delete A[S]:A[S]=!0;return A}D(mt,"getDirtyFieldsFromDefaultValues");var Le=D((p,k)=>mt(p,k,Ce(k)),"getDirtyFields"),ht=D((p,{valueAsNumber:k,valueAsDate:A,setValueAs:O})=>Z(p)?p:k?p===""?NaN:p&&+p:A&&ie(p)?new Date(p):O?O(p):p,"getFieldValueAs");function Te(p){const k=p.ref;if(!(p.refs?p.refs.every(A=>A.disabled):k.disabled))return Ue(k)?k.files:Be(k)?ft(p.refs).value:dt(k)?[...k.selectedOptions].map(({value:A})=>A):ke(k)?ut(p.refs).value:ht(Z(k.value)?p.ref.value:k.value,p)}D(Te,"getFieldValue");var Nt=D((p,k,A,O)=>{const S={};for(const w of p){const b=T(k,w);b&&U(S,w,b._f)}return{criteriaMode:A,names:[...p],fields:S,shouldUseNativeValidation:O}},"getResolverOptions"),xe=D(p=>Z(p)?void 0:Ee(p)?p.source:Y(p)?Ee(p.value)?p.value.source:p.value:p,"getRuleValue"),Mt=D(p=>p.mount&&(p.required||p.min||p.max||p.maxLength||p.minLength||p.pattern||p.validate),"hasValidation");function tt(p,k,A){const O=T(p,A);if(O||ze(A))return{error:O,name:A};const S=A.split(".");for(;S.length;){const w=S.join("."),b=T(k,w),o=T(p,w);if(b&&!Array.isArray(b)&&A!==w)return{name:A};if(o&&o.type)return{name:w,error:o};S.pop()}return{name:A}}D(tt,"schemaErrorLookup");var Lt=D((p,k,A,O,S)=>S.isOnAll?!1:!A&&S.isOnTouch?!(k||p):(A?O.isOnBlur:S.isOnBlur)?!p:(A?O.isOnChange:S.isOnChange)?p:!0,"skipValidation"),Tt=D((p,k)=>!Se(T(p,k)).length&&Q(p,k),"unsetEmptyArray");const Pt={mode:ae.onSubmit,reValidateMode:ae.onChange,shouldFocusError:!0};function qt(p={}){let k={...Pt,...p},A={submitCount:0,isDirty:!1,isValidating:!1,isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,touchedFields:{},dirtyFields:{},errors:{}},O={},S=ye(k.defaultValues)||{},w=k.shouldUnregister?{}:ye(S),b={action:!1,mount:!1,watch:!1},o={mount:new Set,unMount:new Set,array:new Set,watch:new Set},v,g=0,f={};const e={isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},n={watch:Ne(),array:Ne(),state:Ne()},a=et(k.mode),s=et(k.reValidateMode),t=k.criteriaMode===ae.all,l=D(R=>C=>{clearTimeout(g),g=window.setTimeout(R,C)},"debounce"),r=D(async()=>{let R=!1;return e.isValid&&(R=k.resolver?re((await _()).errors):await m(O,!0),R!==A.isValid&&(A.isValid=R,n.state.next({isValid:R}))),R},"_updateValid"),i=D((R,C=[],F,L,P=!0,I=!0)=>{if(L&&F){if(b.action=!0,I&&Array.isArray(T(O,R))){const q=F(T(O,R),L.argA,L.argB);P&&U(O,R,q)}if(e.errors&&I&&Array.isArray(T(A.errors,R))){const q=F(T(A.errors,R),L.argA,L.argB);P&&U(A.errors,R,q),Tt(A.errors,R)}if(e.touchedFields&&I&&Array.isArray(T(A.touchedFields,R))){const q=F(T(A.touchedFields,R),L.argA,L.argB);P&&U(A.touchedFields,R,q)}e.dirtyFields&&(A.dirtyFields=Le(S,w)),n.state.next({isDirty:$(R,C),dirtyFields:A.dirtyFields,errors:A.errors,isValid:A.isValid})}else U(w,R,C)},"_updateFieldArray"),c=D((R,C)=>{U(A.errors,R,C),n.state.next({errors:A.errors})},"updateErrors"),d=D((R,C,F,L)=>{const P=T(O,R);if(P){const I=T(w,R,Z(F)?T(S,R):F);Z(I)||L&&L.defaultChecked||C?U(w,R,C?I:Te(P._f)):N(R,I),b.mount&&r()}},"updateValidAndValue"),y=D((R,C,F,L,P)=>{let I=!1;const q={name:R},G=T(A.touchedFields,R);if(e.isDirty){const J=A.isDirty;A.isDirty=q.isDirty=$(),I=J!==q.isDirty}if(e.dirtyFields&&(!F||L)){const J=T(A.dirtyFields,R);we(T(S,R),C)?Q(A.dirtyFields,R):U(A.dirtyFields,R,!0),q.dirtyFields=A.dirtyFields,I=I||J!==T(A.dirtyFields,R)}return F&&!G&&(U(A.touchedFields,R,F),q.touchedFields=A.touchedFields,I=I||e.touchedFields&&G!==F),I&&P&&n.state.next(q),I?q:{}},"updateTouchAndDirty"),x=D((R,C,F,L)=>{const P=T(A.errors,R),I=e.isValid&&Ae(C)&&A.isValid!==C;if(p.delayError&&F?(v=l(()=>c(R,F)),v(p.delayError)):(clearTimeout(g),v=null,F?U(A.errors,R,F):Q(A.errors,R)),(F?!we(P,F):P)||!re(L)||I){const q={...L,...I&&Ae(C)?{isValid:C}:{},errors:A.errors,name:R};A={...A,...q},n.state.next(q)}f[R]--,e.isValidating&&!Object.values(f).some(q=>q)&&(n.state.next({isValidating:!1}),f={})},"shouldRenderByError"),_=D(async R=>k.resolver?await k.resolver({...w},k.context,Nt(R||o.mount,O,k.criteriaMode,k.shouldUseNativeValidation)):{},"_executeSchema"),u=D(async R=>{const{errors:C}=await _();if(R)for(const F of R){const L=T(C,F);L?U(A.errors,F,L):Q(A.errors,F)}else A.errors=C;return C},"executeSchemaAndUpdateState"),m=D(async(R,C,F={valid:!0})=>{for(const L in R){const P=R[L];if(P){const{_f:I,...q}=P;if(I){const G=o.array.has(I.name),J=await Xe(P,T(w,I.name),t,k.shouldUseNativeValidation,G);if(J[I.name]&&(F.valid=!1,C))break;!C&&(T(J,I.name)?G?Et(A.errors,J,I.name):U(A.errors,I.name,J[I.name]):Q(A.errors,I.name))}q&&await m(q,C,F)}}return F.valid},"executeBuiltInValidation"),h=D(()=>{for(const R of o.unMount){const C=T(O,R);C&&(C._f.refs?C._f.refs.every(F=>!Me(F)):!Me(C._f.ref))&&ee(R)}o.unMount=new Set},"_removeUnmounted"),$=D((R,C)=>(R&&C&&U(w,R,C),!we(ne(),S)),"_getDirty"),j=D((R,C,F)=>{const L={...b.mount?w:Z(C)?S:ie(R)?{[R]:C}:C};return Ot(R,o,L,F)},"_getWatch"),E=D(R=>Se(T(b.mount?w:S,R,p.shouldUnregister?T(S,R,[]):[])),"_getFieldArray"),N=D((R,C,F={})=>{const L=T(O,R);let P=C;if(L){const I=L._f;I&&(!I.disabled&&U(w,R,ht(C,I)),P=qe&&Ve(I.ref)&&X(C)?"":C,dt(I.ref)?[...I.ref.options].forEach(q=>q.selected=P.includes(q.value)):I.refs?ke(I.ref)?I.refs.length>1?I.refs.forEach(q=>(!q.defaultChecked||!q.disabled)&&(q.checked=Array.isArray(P)?!!P.find(G=>G===q.value):P===q.value)):I.refs[0]&&(I.refs[0].checked=!!P):I.refs.forEach(q=>q.checked=q.value===P):Ue(I.ref)?I.ref.value="":(I.ref.value=P,I.ref.type||n.watch.next({name:R})))}(F.shouldDirty||F.shouldTouch)&&y(R,P,F.shouldTouch,F.shouldDirty,!0),F.shouldValidate&&K(R)},"setFieldValue"),M=D((R,C,F)=>{for(const L in C){const P=C[L],I=`${R}.${L}`,q=T(O,I);(o.array.has(R)||!De(P)||q&&!q._f)&&!_e(P)?M(I,P,F):N(I,P,F)}},"setValues"),V=D((R,C,F={})=>{const L=T(O,R),P=o.array.has(R),I=ye(C);U(w,R,I),P?(n.array.next({name:R,values:w}),(e.isDirty||e.dirtyFields)&&F.shouldDirty&&(A.dirtyFields=Le(S,w),n.state.next({name:R,dirtyFields:A.dirtyFields,isDirty:$(R,I)}))):L&&!L._f&&!X(I)?M(R,I,F):N(R,I,F),Ke(R,o)&&n.state.next({}),n.watch.next({name:R})},"setValue"),W=D(async R=>{const C=R.target;let F=C.name;const L=T(O,F);if(L){let P,I;const q=C.type?Te(L._f):wt(R),G=R.type===Ge.BLUR||R.type===Ge.FOCUS_OUT,J=!Mt(L._f)&&!k.resolver&&!T(A.errors,F)&&!L._f.deps||Lt(G,T(A.touchedFields,F),A.isSubmitted,s,a),Re=Ke(F,o,G);U(w,F,q),G?(L._f.onBlur&&L._f.onBlur(R),v&&v(0)):L._f.onChange&&L._f.onChange(R);const Fe=y(F,q,G,!1),bt=!re(Fe)||Re;if(!G&&n.watch.next({name:F,type:R.type}),J)return e.isValid&&r(),bt&&n.state.next({name:F,...Re?{}:Fe});if(!G&&Re&&n.state.next({}),f[F]=f[F]?f[F]+1:1,n.state.next({isValidating:!0}),k.resolver){const{errors:We}=await _([F]),vt=tt(A.errors,O,F),He=tt(We,O,vt.name||F);P=He.error,F=He.name,I=re(We)}else P=(await Xe(L,T(w,F),t,k.shouldUseNativeValidation))[F],r();L._f.deps&&K(L._f.deps),x(F,I,P,Fe)}},"onChange"),K=D(async(R,C={})=>{let F,L;const P=Ie(R);if(n.state.next({isValidating:!0}),k.resolver){const I=await u(Z(R)?R:P);F=re(I),L=R?!P.some(q=>T(I,q)):F}else R?(L=(await Promise.all(P.map(async I=>{const q=T(O,I);return await m(q&&q._f?{[I]:q}:q)}))).every(Boolean),!(!L&&!A.isValid)&&r()):L=F=await m(O);return n.state.next({...!ie(R)||e.isValid&&F!==A.isValid?{}:{name:R},...k.resolver||!R?{isValid:F}:{},errors:A.errors,isValidating:!1}),C.shouldFocus&&!L&&Pe(O,I=>I&&T(A.errors,I),R?P:o.mount),L},"trigger"),ne=D(R=>{const C={...S,...b.mount?w:{}};return Z(R)?C:ie(R)?T(C,R):R.map(F=>T(C,F))},"getValues"),oe=D((R,C)=>({invalid:!!T((C||A).errors,R),isDirty:!!T((C||A).dirtyFields,R),isTouched:!!T((C||A).touchedFields,R),error:T((C||A).errors,R)}),"getFieldState"),B=D(R=>{R?Ie(R).forEach(C=>Q(A.errors,C)):A.errors={},n.state.next({errors:A.errors})},"clearErrors"),H=D((R,C,F)=>{const L=(T(O,R,{_f:{}})._f||{}).ref;U(A.errors,R,{...C,ref:L}),n.state.next({name:R,errors:A.errors,isValid:!1}),F&&F.shouldFocus&&L&&L.focus&&L.focus()},"setError"),te=D((R,C)=>Oe(R)?n.watch.subscribe({next:F=>R(j(void 0,C),F)}):j(R,C,!0),"watch"),ee=D((R,C={})=>{for(const F of R?Ie(R):o.mount)o.mount.delete(F),o.array.delete(F),T(O,F)&&(C.keepValue||(Q(O,F),Q(w,F)),!C.keepError&&Q(A.errors,F),!C.keepDirty&&Q(A.dirtyFields,F),!C.keepTouched&&Q(A.touchedFields,F),!k.shouldUnregister&&!C.keepDefaultValue&&Q(S,F));n.watch.next({}),n.state.next({...A,...C.keepDirty?{isDirty:$()}:{}}),!C.keepIsValid&&r()},"unregister"),pe=D((R,C={})=>{let F=T(O,R);const L=Ae(C.disabled);return U(O,R,{...F||{},_f:{...F&&F._f?F._f:{ref:{name:R}},name:R,mount:!0,...C}}),o.mount.add(R),F?L&&U(w,R,C.disabled?void 0:T(w,R,Te(F._f))):d(R,!0,C.value),{...L?{disabled:C.disabled}:{},...k.shouldUseNativeValidation?{required:!!C.required,min:xe(C.min),max:xe(C.max),minLength:xe(C.minLength),maxLength:xe(C.maxLength),pattern:xe(C.pattern)}:{},name:R,onChange:W,onBlur:W,ref:P=>{if(P){pe(R,C),F=T(O,R);const I=Z(P.value)&&P.querySelectorAll&&P.querySelectorAll("input,select,textarea")[0]||P,q=It(I),G=F._f.refs||[];if(q?G.find(J=>J===I):I===F._f.ref)return;U(O,R,{_f:{...F._f,...q?{refs:[...G.filter(Me),I,...Array.isArray(T(S,R))?[{}]:[]],ref:{type:I.type,name:R}}:{ref:I}}}),d(R,!1,void 0,I)}else F=T(O,R,{}),F._f&&(F._f.mount=!1),(k.shouldUnregister||C.shouldUnregister)&&!($t(o.array,R)&&b.action)&&o.unMount.add(R)}}},"register"),be=D(()=>k.shouldFocusError&&Pe(O,R=>R&&T(A.errors,R),o.mount),"_focusError"),ge=D((R,C)=>async F=>{F&&(F.preventDefault&&F.preventDefault(),F.persist&&F.persist());let L=!0,P=ye(w);n.state.next({isSubmitting:!0});try{if(k.resolver){const{errors:I,values:q}=await _();A.errors=I,P=q}else await m(O);re(A.errors)?(n.state.next({errors:{},isSubmitting:!0}),await R(P,F)):(C&&await C({...A.errors},F),be())}catch(I){throw L=!1,I}finally{A.isSubmitted=!0,n.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:re(A.errors)&&L,submitCount:A.submitCount+1,errors:A.errors})}},"handleSubmit"),gt=D((R,C={})=>{T(O,R)&&(Z(C.defaultValue)?V(R,T(S,R)):(V(R,C.defaultValue),U(S,R,C.defaultValue)),C.keepTouched||Q(A.touchedFields,R),C.keepDirty||(Q(A.dirtyFields,R),A.isDirty=C.defaultValue?$(R,T(S,R)):$()),C.keepError||(Q(A.errors,R),e.isValid&&r()),n.state.next({...A}))},"resetField"),yt=D((R,C={})=>{const F=R||S,L=ye(F),P=R&&!re(R)?L:S;if(C.keepDefaultValues||(S=F),!C.keepValues){if(C.keepDirtyValues)for(const I of o.mount)T(A.dirtyFields,I)?U(P,I,T(w,I)):V(I,T(P,I));else{if(qe&&Z(R))for(const I of o.mount){const q=T(O,I);if(q&&q._f){const G=Array.isArray(q._f.refs)?q._f.refs[0]:q._f.ref;if(Ve(G)){const J=G.closest("form");if(J){J.reset();break}}}}O={}}w=p.shouldUnregister?C.keepDefaultValues?ye(S):{}:L,n.array.next({values:P}),n.watch.next({values:P})}o={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:""},b.mount=!e.isValid||!!C.keepIsValid,b.watch=!!p.shouldUnregister,n.state.next({submitCount:C.keepSubmitCount?A.submitCount:0,isDirty:C.keepDirty||C.keepDirtyValues?A.isDirty:!!(C.keepDefaultValues&&!we(R,S)),isSubmitted:C.keepIsSubmitted?A.isSubmitted:!1,dirtyFields:C.keepDirty||C.keepDirtyValues?A.dirtyFields:C.keepDefaultValues&&R?Le(S,R):{},touchedFields:C.keepTouched?A.touchedFields:{},errors:C.keepErrors?A.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})},"_reset");return{control:{register:pe,unregister:ee,getFieldState:oe,_executeSchema:_,_focusError:be,_getWatch:j,_getDirty:$,_updateValid:r,_removeUnmounted:h,_updateFieldArray:i,_getFieldArray:E,_subjects:n,_proxyFormState:e,get _fields(){return O},get _formValues(){return w},get _stateFlags(){return b},set _stateFlags(R){b=R},get _defaultValues(){return S},get _names(){return o},set _names(R){o=R},get _formState(){return A},set _formState(R){A=R},get _options(){return k},set _options(R){k={...k,...R}}},trigger:K,register:pe,handleSubmit:ge,watch:te,setValue:V,getValues:ne,reset:D((R,C)=>yt(Oe(R)?R(w):R,C),"reset"),resetField:gt,clearErrors:B,unregister:ee,setError:H,setFocus:D((R,C={})=>{const F=T(O,R),L=F&&F._f;if(L){const P=L.refs?L.refs[0]:L.ref;P.focus&&(P.focus(),C.shouldSelect&&P.select())}},"setFocus"),getFieldState:oe}}D(qt,"createFormControl");function Vt(p={}){const k=ue.useRef(),[A,O]=ue.useState({isDirty:!1,isValidating:!1,isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,submitCount:0,dirtyFields:{},touchedFields:{},errors:{},defaultValues:p.defaultValues});k.current||(k.current={...qt(p),formState:A});const S=k.current.control;return S._options=p,jt({subject:S._subjects.state,callback:ue.useCallback(w=>{Rt(w,S._proxyFormState,!0)&&(S._formState={...S._formState,...w},O({...S._formState}))},[S])}),ue.useEffect(()=>{S._stateFlags.mount||(S._proxyFormState.isValid&&S._updateValid(),S._stateFlags.mount=!0),S._stateFlags.watch&&(S._stateFlags.watch=!1,S._subjects.state.next({})),S._removeUnmounted()}),ue.useEffect(()=>{A.submitCount&&S._focusError()},[S,A.submitCount]),k.current.formState=St(A,S),k.current}D(Vt,"useForm");var rt=D(function(p,k,A){if(p&&"reportValidity"in p){var O=T(A,k);p.setCustomValidity(O&&O.message||""),p.reportValidity()}},"e"),pt=D(function(p,k){var A=D(function(S){var w=k.fields[S];w&&w.ref&&"reportValidity"in w.ref?rt(w.ref,S,p):w.refs&&w.refs.forEach(function(b){return rt(b,S,p)})},"t");for(var O in k.fields)A(O)},"t"),zt=D(function(p,k){k.shouldUseNativeValidation&&pt(p,k);var A={};for(var O in p){var S=T(k.fields,O);U(A,O,Object.assign(p[O],{ref:S&&S.ref}))}return A},"f"),Ut=D(function(p,k,A){return k===void 0&&(k={abortEarly:!1}),A===void 0&&(A={}),function(O,S,w){try{var b=D(function(){return v.error?{values:{},errors:zt((f=v.error,e=!w.shouldUseNativeValidation&&w.criteriaMode==="all",f.details.length?f.details.reduce(function(n,a){var s=a.path.join(".");if(n[s]||(n[s]={message:a.message,type:a.type}),e){var t=n[s].types,l=t&&t[a.type];n[s]=lt(s,e,n,a.type,l?[].concat(l,a.message):a.message)}return n},{}):{}),w)}:(w.shouldUseNativeValidation&&pt({},w),{errors:{},values:v.value});var f,e},"c"),o=Object.assign({},k,{context:S}),v={},g=function(){if(A.mode==="sync")v=p.validate(O,o);else{var f=function(e,n){try{var a=e()}catch(s){return n(s)}return a&&a.then?a.then(void 0,n):a}(function(){return Promise.resolve(p.validateAsync(O,o)).then(function(e){v.value=e})},function(e){v.error=e});if(f&&f.then)return f.then(function(){})}}();return Promise.resolve(g&&g.then?g.then(b):b())}catch(f){return Promise.reject(f)}}},"n"),de=D(function(p){var k=p.as,A=p.errors,O=p.name,S=p.message,w=p.render,b=function(n,a){if(n==null)return{};var s,t,l={},r=Object.keys(n);for(t=0;t<r.length;t++)a.indexOf(s=r[t])>=0||(l[s]=n[s]);return l}(p,["as","errors","name","message","render"]),o=kt(),v=T(A||o.formState.errors,O);if(!v)return null;var g=v.message,f=v.types,e=Object.assign({},b,{children:g||S});return $e.exports.isValidElement(k)?$e.exports.cloneElement(k,e):w?w({message:g||S,messages:f}):$e.exports.createElement(k||$e.exports.Fragment,e)},"s");function me({children:p,className:k,...A}){return z("label",{...A,className:at("text-sm font-medium text-gray-400 peer-placeholder-shown:text-neutral-600 peer-invalid:text-red-500",k),children:p})}D(me,"Label");const se=$e.exports.forwardRef(({className:p,type:k,...A},O)=>z("input",{ref:O,...A,type:k,className:at("peer block text-neutral-600 leading-snug px-4 py-3 rounded border-gray-300 placeholder:text-gray-300 focus:ring-0 focus:outline-0 focus:border-gray-400 focus:invalid:border-red-500 invalid:border-red-500 w-full",p)}));se.displayName="Input";function he({message:p}){return z("span",{role:"alert","aria-label":p,className:"block text-sm text-red-500",children:p})}D(he,"Feedback");const Bt=ce.object({firstname:ce.string().trim().required().label("firstname"),lastname:ce.string().trim().required().label("lastname"),id:ce.string().trim().required().label("id"),phone:ce.string().trim().required().label("phone number"),email:ce.string().trim().email({tlds:{allow:!1}}).required().label("email"),password:ce.string().trim().required().label("password"),confirmPassword:ce.any().valid(ce.ref("password")).required().messages({"any.only":"Passwords must match each other"}),termsConditions:ce.boolean().equal(!0).required().messages({"any.only":"Terms must be accepted"})}).messages({"string.empty":"{#label} is a required field"});function Zt({onSubmit:p}){const{handleSubmit:k,register:A,formState:{errors:O}}=Vt({shouldUseNativeValidation:!0,resolver:Ut(Bt)});return le("form",{onSubmit:k(p),children:[le("div",{className:"grid grid-cols-2 gap-y-8 gap-x-4",children:[z("div",{className:"col-span-2",children:le("div",{className:"relative",children:[z(se,{type:"text",id:"firstname",autoComplete:"given-name",...A("firstname"),placeholder:"Enter your firstname"}),z(me,{htmlFor:"firstname",className:"absolute left-2 -top-3 bg-white px-2",children:"Firstname"}),z(de,{errors:O,name:"firstname",render:he})]})}),z("div",{className:"col-span-2",children:le("div",{className:"relative",children:[z(se,{type:"text",id:"lastname",...A("lastname"),autoComplete:"family-name",placeholder:"Enter your lastname"}),z(me,{htmlFor:"lastname",className:"absolute left-2 -top-3 bg-white px-2",children:"Lastname"}),z(de,{name:"lastname",errors:O,render:he})]})}),z("div",{className:"col-span-2 sm:col-span-1",children:le("div",{className:"relative",children:[z(se,{id:"id",type:"text",...A("id"),placeholder:"Enter your ID"}),z(me,{htmlFor:"id",className:"absolute left-2 -top-3 bg-white px-2",children:"ID"}),z(de,{name:"id",errors:O,render:he})]})}),z("div",{className:"col-span-2 sm:col-span-1",children:le("div",{className:"relative",children:[z(se,{id:"phone",type:"tel",autoComplete:"tel",...A("phone"),placeholder:"Enter your phone number"}),z(me,{htmlFor:"phone",className:"absolute left-2 -top-3 bg-white px-2",children:"Phone"}),z(de,{name:"phone",errors:O,render:he})]})}),z("div",{className:"col-span-2",children:le("div",{className:"relative",children:[z(se,{id:"email",type:"email",autoComplete:"email",...A("email"),placeholder:"Enter your email"}),z(me,{htmlFor:"email",className:"absolute left-2 -top-3 bg-white px-2",children:"Email"}),z(de,{name:"email",errors:O,render:he})]})}),z("div",{className:"col-span-2",children:le("div",{className:"relative",children:[z(se,{id:"password",type:"password",...A("password"),autoComplete:"new-password",placeholder:"Enter your password"}),z(me,{htmlFor:"password",className:"absolute left-2 -top-3 bg-white px-2",children:"Password"}),z(de,{name:"password",errors:O,render:he})]})}),z("div",{className:"col-span-2",children:le("div",{className:"relative",children:[z(se,{type:"password",id:"confirm-password",autoComplete:"new-password",...A("confirmPassword"),placeholder:"Enter your password again"}),z(me,{htmlFor:"confirm-password",className:"absolute left-2 -top-3 bg-white px-2",children:"Confirm Password"}),z(de,{errors:O,render:he,name:"confirmPassword"})]})}),le("div",{className:"col-span-2",children:[z(se,{type:"checkbox",id:"terms-conditions",...A("termsConditions"),className:"inline-block text-blue-500 px-2 py-2 w-auto"}),z(me,{htmlFor:"terms-conditions",className:"font-normal ml-3",children:"Agree to terms and conditions"}),z(de,{errors:O,render:he,name:"termsConditions"})]})]}),z("div",{className:"text-center mt-9",children:z("button",{type:"submit",className:"bg-blue-500 hover:bg-blue-600 active:bg-blue-700 focus:bg-blue-700 text-white font-medium py-[10px] px-4 rounded-md focus:ring focus:ring-blue-500 focus:ring-offset-1 min-w-[205px]",children:"Sign up"})})]})}D(Zt,"SignupForm");try{se.displayName="Input",se.__docgenInfo={description:"",displayName:"Input",props:{onSubmit:{defaultValue:null,description:"",name:"onSubmit",required:!0,type:{name:"(data: SignupUser) => void"}}}},typeof STORYBOOK_REACT_CLASSES<"u"&&(STORYBOOK_REACT_CLASSES["src/auth/signup-form.tsx#Input"]={docgenInfo:se.__docgenInfo,name:"Input",path:"src/auth/signup-form.tsx#Input"})}catch{}export{Zt as S};
//# sourceMappingURL=signup-form.538706ea.js.map
